# OS-Course Slides <!-- markmap: foldAll --> 

## 第一讲 操作系统概述

### 第一讲总结
- 知识点
	- 操作系统定义
		- 操作系统是**管理硬件资源**、控制程序运行、改善人机界面和**为应用软件提供支持**的一种系统**软件**
	- 内核基本抽象
		- 进程 -- CPU
		- 文件 -- 存储(I/O)设备
		- 地址空间 -- 内存(+存储)
	- 内核特征
		- 并发
		- 共享
		- 虚拟
		- 异步 
	- 内核演进
		- 批处理系统
    		- 一次只加载一个任务/作业到内存中执行 
		- 多道程序系统
    		- 可加载多个不同任务/作业到内存中执行 
		- 分时系统
      	- 可加载多个不同任务到内存中执行 
				- CTSS
				- Multics
				- UNIX + C -- Ken Thompson + Dennis Ritchie
				- Linux	使用最广泛的OS
				- Android with Linux kernel
	- 内核架构
		- 简单结构 -- DOS
		- 单体分层结构（宏内核） -- UNIX
		- 微内核 -- Mach、seL4、MINIX
		- 外核 -- exokernel from MIT，演进为虚拟机管理器 VMM or Hypervisor  
	- 实践能力
		- 会使用基本Linux命令: ls、rm、gcc、gdb、make、git、ps、cat
		- 了解Linux基本系统调用：fork、exit、wait、kill、getpid、sleep、exec、sbrk、open、write、read、close、dup、pipe、chdir、mkdir、mknod、fstat、stat、link、unlink
		- 理解、编译、运行Linux程序：fork.c、exec.c、forkexec.c等




### 第一节 课程概述 & 教学安排
- [课程幻灯片列表](https://www.yuque.com/xyong-9fuoz/qczol5/ewvhdy3epbwbkn3n)
- 课程信息
    - 主讲教师：向勇 陈渝 李国良 任炬
    - 助教：饶淙元、田凯夫、闭浩扬、王拓为、苏明贤、黄旺、郝子胥
- 上课信息
    - 上课时间地点
    - 时间：星期一 第2大节 上午09:50-12:15 (1-16周) 
    - 地点：六教6A209（任）六教6A211（李）六教6A213（陈）
- 预备知识
    - 程序设计语言（汇编、C 和 Rust）
    - 不是开发应用程序 :confounded:
    - 而是开发系统程序 :smile:
    - 数据结构
    - 理解基本数据结构即可 :smile:
    - 计算机组成原理
    - 刘总/康总/陆总的 RISC-V 原理 :smile: :smile: :smile:
    - Patterson 的 RISC-V 原理 :smile:
    - 编译原理
    - 没学过影响不大 :smile:
    - 但还是要了解高级语言 <–>RISC-V 汇编语言 :smile:
- 课程参考与实践
    - [课程幻灯片](https://www.yuque.com/xyong-9fuoz/qczol5/ewvhdy3epbwbkn3n)
    - 参考书籍
    - [Operating Systems: Three Easy Pieces](https://pages.cs.wisc.edu/~remzi/OSTEP/)
    - [深入了解计算机系统](https://hansimov.gitbook.io/csapp/)
    - [RISC-V Reader中文版](http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf)
    - 课程实践
    - [rCore Tutorial Book v3](https://learningos.github.io/rCore-Tutorial-Book-v3/)
    - [代码仓库](https://github.com/rcore-os/rCore-Tutorial-v3)
    - [API文档](https://github.com/rcore-os/rCore-Tutorial-v3#os-api-docs)
- 实验指导
    - uCore Tutorial
    - [实验代码](https://github.com/LearningOS/uCore-Tutorial-Code-2024S/)
    - [实验文档](https://learningos.github.io/uCore-Tutorial-Guide-2024S/)
    - [测试用例](https://github.com/LearningOS/uCore-Tutorial-Test-2024S/)
    - rCore Tutorial
    - [实验文档](https://learningos.github.io/rCore-Tutorial-Guide-2024S/)
    - [API文档](https://github.com/LearningOS/rCore-Tutorial-Guide-2024S/#os-api-docs-of-rcore-tutorial-code-2022a)
    - [实验代码](https://github.com/LearningOS/rCore-Tutorial-Code-2024S)
    - [测试用例](https://github.com/LearningOS/rCore-Tutorial-Test-2024S)
    - [uCore和rCore实验帮助](https://www.yuque.com/xyong-9fuoz/qczol5/lt5qafszpz62hob1?singleDoc)
    - 讲解视频
    - 部分内容将逐步更新
- OS 原理与设计思想
    - 操作系统结构
    - 中断及系统调用
    - 内存管理
    - 进程管理
    - 处理机调度
    - 同步互斥
    - 文件系统
    - I/O 子系统
- 作业与实验
    - 平时作业
    - 课后练习：包括问答题和编程题目，要求在deadline前提交
    - 基础实验
    - （必做）面向 RISC-V CPU 用 Rust/C 设计实现操作系统的功能
    - （选做）难度和工作量比必做题目大的其它题目
    - 课程设计（大实验）
    - 用组件来组合操作系统内核
    - 参加全国大学生OS比赛
- 基础实验详细内容
    - 实验一：操作系统的基本支持
    - 实验二：地址空间
    - 实验三：进程管理与调度
    - 实验四：文件系统与进程间通信
    - 实验五：同步互斥
- 课程设计（大实验）
    - 用组件来组合操作系统内核
    - 组件化操作系统[ArceOS](http://arceos.org/overview.html)
    - 操作系统功能和扩展
    - 内核模块的完善和改进
    - 内核可加载模块、微内核、在内核中引入异步编程
    - 支持多种处理器架构和硬件平台
    - GUI、驱动、文件系统、网络
    - 往届同学的[课程设计成果](https://shimo.im/docs/QTPRT8h8jyGQCqkJ)
- 成绩评定
    - 选择1
    - 实验一~五必做题目：40%
    - 期中考试：20%
    - 期末考试：40%
    - 加分：平时作业每做一次加1分，最高加5分
    - 选择2
    - 四周内完成实验一~五：40%
    - 课程设计（即大实验）：60%
- 调查问卷
    - [2024年春季学期操作系统课选课问卷](http://oscourse2019.mikecrm.com/TdGsawl)

### 第二节 什么是操作系统
- 操作系统定义
  - 没有公认的精确定义
  - 功能
    - 管理硬件资源
    - 控制程序运行
    - 改善人机界面
    - 为应用软件提供支持
  - 描述来源: [计算机百科全书]

- 操作系统的角色
  - 资源管理程序
    - 应用与硬件之间的中间层
    - 管理各种软硬件资源
    - 提供访问软硬件资源的服务
    - 解决访问冲突，确保公平使用
  - 控制程序
    - 执行程序，给程序提供服务
    - 控制程序执行过程，防止错误
    - 方便用户使用计算机系统

- 操作系统的软件分类
  - Shell: 命令行接口
  - GUI: 图形用户接口
  - Kernel: 操作系统的内部

- uCore/rCore 教学操作系统内核
  - 内核结构图展示

- 操作系统内核的抽象
  - 内核抽象图展示

- 操作系统内核的特征
  - 并发: 多个程序同时运行
  - 共享: 程序间“同时”访问互斥共享资源
  - 虚拟: 每个程序“独占”一台完整计算机
  - 异步: 服务完成时间不确定，可能失败

- 对操作系统内核的理解
  - 用户/应用对操作系统的需求
    - 高效性 vs 易用性
    - 强大的操作系统服务 vs 简单的接口
    - 灵活性 vs 安全性

- 为什么要学习这门课程
  - 了解计算机机壳后面的软硬件运行原理
  - 学习软硬件基础架构和原理
  - 深入了解程序运行机理
  - 发现并修复难以对付的bug
### 第三节 操作系统历史演化
- 操作系统的历史发展
  - 单用户系统 (1945-1955)
      - 手动连线/纸带传输进行程序输入
      - 机器成本远大于人力成本
      - 操作系统 = 装载器 + 程序库
      - 问题：昂贵组件的低利用率
  - 批处理系统 (1955-1965)
      - 磁带/磁盘传输进行程序输入
      - 操作系统 = 装载器 + 程序控制器 + 输出处理器
      - 问题：相比以前利用率提高
  - 多道程序系统 (1955-1980)
      - 多个程序驻留内存中
      - 多个程序轮流使用 CPU
      - 操作系统 = 装载器 + 程序调度 + 内存管理 + 输出管理
      - 演变：相比以前利用率提高
  - 分时系统 (1970-至今)
      - 多个程序分时使用 CPU
      - 操作系统 = 装载器 + 程序调度 + 内存管理 + 中断处理
      - 演变：利用率提高、交互延时缩短

- 操作系统家族和影响
  - Multics OS
      - 高级别安全和多用户操作系统
  - UNIX（Ken Thompson 与 Dennis Ritchie）
      - 开放系统，多用户支持
  - Linux家族
      - 开源和自由软件运动的产物
  - 个人电脑 (1981- )
      - 单用户
      - 重点是用户界面和多媒体功能
      - 操作系统 = 装载器 + 程序调度 + 内存管理 + 中断处理
      - 演变：走向大众，老的服务和功能不存在，越来越多的安全问题
  - MacOS家族
      - 基于UNIX的图形界面系统
  - Windows家族
      - 微软开发，主导个人计算市场

- 特定领域操作系统
  - 分布式系统 (1990- )
      - 分布式多用户
      - 重点是网络/存储/计算的效率
      - 操作系统 = 分布式（装载器 + 程序/OS 调度 + 内存管理）
      - 演变：走向网络，新的挑战（不可靠/不确定性）
  - Android操作系统
      - 跨平台：支持Java应用程序
      - 运行时：Android虚拟机
      - 应用框架：简化应用程序开发
  - AIoT操作系统
      - 分布式多设备
      - 重点是网络/存储/计算的效率
      - 操作系统 = 分布式（程序/OS 调度 + 内存管理 + 安全/更新）
      - 演变：走向设备，走向网络，新的挑战（不可靠/大数据）

### 第四节 操作系统结构
- 操作系统的不同结构
  - 简单结构
      - MS-DOS：应用和OS混在一起 (1981–1994)
      - 没有拆分为模块
      - 主要用汇编编写
      - 没有安全保护
      
  - 单体分层结构
      - 将单体操作系统划分为多层
      - 每层建立在低层之上
      - 最底层 (layer 0) 是硬件驱动
      - 最高层 (layer N) 是用户界面
      - 每一层仅使用更低一层的功能和服务

  - 微内核结构 (Micro Kernel)
      - 尽可能把内核功能移到用户空间
      - 用户模块间通信使用消息传递
      - 好处: 灵活、安全...
      - 缺点: 性能问题
      - LPC: 本地过程调用
      - HAL: 硬件抽象层

  - 外核结构 (Exokernel)
      - 内核分配物理资源给多个应用程序
      - 让每个程序决定如何处理这些资源
      - 程序能链接到操作系统库 (libOS) 实现了操作系统抽象
      - 保护与控制分离
      - Distributed Shared Memory (DSM)

  - 虚拟机结构
      - 虚拟机管理器将单独的机器接口转换成很多的虚拟机
      - 每个虚拟机都是一个原始计算机系统的有效副本
      - 能完成所有的处理器指令

- 应用程序运行与 OS 抽象 + 架构的关系
  - 说明了应用程序在不同操作系统架构中的运行方式与OS提供的环境和抽象的关系

### 第五节 实践：试试UNIX/Linux
- UNIX/Linux 系统介绍
    - 常见的Linux发行版
    - Ubuntu、Fedora、SuSE、openEuler
    - 麒麟、统信
    - 其他系统支持
    - Windows with WSL (Windows Subsystem for Linux)
    - MacOS with UNIX shell

- UNIX/Linux的特点
    - 开放源码，有很好的文档，设计简洁，使用广泛
    - 对学习ucore/rcore内部情况有帮助

- 尝试使用UNIX/Linux
    - Shell环境
    - bash: 基本的shell环境
    - fish: 强调交互性和可用性
    - zsh: 带有自动补全、支持插件
    - starship: 轻量、迅速、可无限定制
    - 常用程序
    - ls, rm，gcc，gdb, vim

- UNIX/Linux提供的服务
    - 进程（正在运行的程序）
    - 内存分配
    - 文件内容、文件名、目录管理
    - 访问控制（安全）
    - 其他服务：用户、IPC、网络、时间

- UNIX/Linux的应用/内核接口
    - 通过系统调用与内核交互
    - 示例: `fd = open("out", 1); write(fd, "hello\n", 6);`
    - 系统调用示例：
    - `int fork()` 创建一个进程，返回子进程的PID
    - `int exit(int status)` 终止当前进程；没有返回
    - `int wait(int *status)` 等待子进程退出；返回子进程的PID
    - `int kill(int pid)` 终止进程号为PID的进程；返回0或-1表示错误
    - `int getpid()` 返回当前进程的PID
    - 更多系统调用：`sleep`, `exec`, `sbrk`, `open`, `write`, `read`, `close`, `dup`, `pipe`, `chdir`, `mkdir`, `mknod`, `fstat`, `stat`, `link`, `unlink`

- UNIX/Linux应用分析
    - 查看和分析简单小程序
    - 进程相关：fork.c, exec.c, forkexec.c
    - 文件系统相关：list.c, open.c, echo.c, copy.c
    - 进程间通信相关：pipe1.c, pipe2.c, redirect.c

## 第二讲 实践与实验介绍

### 第二讲总结
- 知识点
  	- 函数调用、栈帧与参数
      	- 函数调用与系统调用的区别
      	- RISC-V函数调用约定
        	- 传递参数的寄存器 a0~a7
        	- 返回值寄存器 a0
        	- caller-saved 寄存器列表
        	- callee-saved 寄存器列表
  	- 编译器/硬件与OS之间的共识
  	- 加电后硬件/软件启动过程
      	- QEMU启动参数的含义
        	- 物理内存大小、起始位置
        	- OS的放置位置
        	- Bootloader的加载
      	- QEMU中的firmware代码及及其含义
      	- QEMU模拟RISC-V计算机的冷启动过程
        	- firmware --> bootloader(rust-sbi) --> uCore/rCore
  	- 开发环境
    	- 编译器、Assembler、Linker
    	- ELF执行文件格式基本含义
    	- linker.ld的含义
  	- 执行环境
    	- OS加载/执行/管理进程
    	- 程序执行中内存布局
  	- LibOS的设计与执行
  		- 裸机编程
    		- 进一步理解App/OS内存布局
    		- 汇编函数 --> Rust/C函数
  		- 裸机程序执行过程
      		- 裸机程序初始化
        		- 建立栈
    	- RISC-V的SBI
        	- SBI服务
        	- 发出SBI调用的汇编代码





### 第一节 实践与实验简要分析
- 提纲
  - 原理、实践与实验介绍
  - 循续渐进的操作系统实验
  - 实验安排

- 操作系统需求逐渐增加
  - LibOS
  - 批处理OS
  - 多道程序与分时多任务OS

- 逐步体现操作系统概念抽象
  - 地址空间抽象的OS
  - 进程抽象的OS
  - 文件抽象的OS

- 逐步体现操作系统关键能力
  - 可进程间通信的OS
  - 可并发的OS
  - 管理I/O设备的OS

- 具体操作系统类型和特点
  - LibOS
      - 远古操作系统雏形
      - 现代简单嵌入式操作系统
      - 相关知识点:
      - 以库的形式提供给应用程序的OS
      - 函数调用: 编译器与操作系统的配合
      - 硬件启动和软件启动
      - 编写/调试裸机程序

  - 批处理OS
      - 内存只驻留单道程序
      - 支持系统调用
      - 相关知识点:
      - 特权级/特权操作
      - RISC-V特权级/特权操作
      - 系统调用/异常
      - 加载&执行&切换应用程序
      - 特权级切换

  - 多道程序OS
      - 支持多个程序同时驻留内存
      - 支持多个程序依次执行
      - 相关知识点:
      - 内存空间划分与管理
      - 协作式调度

  - 分时多任务OS
      - 支持多个程序轮流执行
      - 相关知识点:
      - 中断处理
      - 上下文切换
      - 抢占式调度

- OS的地址空间抽象
    - 支持程序间内存空间隔离
    - 超越物理内存的虚拟存储
    - 相关知识点:
    - 地址空间抽象
    - 静态内存分配
    - 动态内存分配
    - 页式存储管理
    - 局部性原理
    - 缺页异常
    - 虚拟页式存储
    - 置换算法

- OS的进程抽象
    - 支持动态创建程序执行
    - 支持多处理器并行
    - 相关知识点:
    - 进程抽象
    - 进程管理
    - 调度机制
    - 多处理器/多核架构
    - 多处理器调度
    - 实际OS调度

- OS的文件抽象
    - 处理数据的便捷持久存储
    - 相关知识点:
    - 文件抽象
    - 文件组织结构
    - 文件系统设计与实现

- 实验安排
  - 实验一：操作系统的基本支持
      - 覆盖内容: LibOS、批处理OS、多道程序与分时多任务OS
      - 知识点：特权级和切换
  - 实验二：地址空间
      - 覆盖内容: 地址空间抽象的OS
      - 知识点：页表
  - 实验三：进程管理与调度
      - 覆盖内容: 进程抽象的OS
      - 知识点：进程控制块PCB
  - 实验四：文件系统与进程间通信
      - 覆盖内容: 文件抽象的OS、可进程间通信的OS
      - 知识点：文件
  - 实验五：同步互斥
      - 覆盖内容: 可并发的OS
      - 知识点: 线程
  - 扩展实验（即大实验，课程设计）
      - 4周内完成基础实验1~5后，与老师协商选择完成扩展实验来代替考试
      - 扩展组件化操作系统的crates/modules/frameworks
          - 实现新feature（多核、新外设、新处理器、新功能）的支持
          - 参加全国大学生OS比赛

### 第二节 Compiler与OS

- 提纲
  - 硬件环境
  - 应用程序执行环境
  - 操作系统执行环境

- 硬件环境
  - 开发的硬件环境 (x86 架构)
  - 目标硬件环境 (RISC-V 架构)

- 应用程序执行环境
  - 编译器工作
    - 源码转换为汇编码
  - Assembler（汇编器）工作
    - 汇编码转换为机器码
  - Linker（链接器）工作
    - 多个机器码目标文件合并为单个机器码执行文件
  - OS工作
    - 加载/执行/管理机器码执行文件

- 操作系统执行环境
  - Compiler/Assembler/Linker 工作流程
    - 从源码到汇编码，再到机器码，最后生成执行程序
    - Bootloader加载OS执行
  - 可执行文件格式
    - 三元组: CPU架构/厂商/操作系统
      - 示例: riscv32gc-unknown-linux-gnu, riscv64gc-unknown-none-elf
      - ELF: Executable and Linkable Format
  - 链接和执行过程展示
  - 函数库
    - 标准库 (依赖操作系统)
      - Rust: std 标准库
      - C：glibc, musl libc 
    - 核心库 (与操作系统无关)
      - Rust: core 核心库
      - C: Linux/BSD kernel libc
  - 裸机程序
    - 定义: 与操作系统无关的OS类型的程序 (Bare Metal program)
    - 示例代码及配置
  - ELF文件格式和文件头信息
    - 文件格式详情
    - 反汇编导出汇编程序指令
    - 主要段和内存布局
      - .text: 代码段
      - .rodata: 已初始化数据段，只读
      - .data: 可修改的全局数据
      - .bss: 未初始化数据段
      - 堆 (heap) 向高地址增长
      - 栈 (stack) 向低地址增长

### 第三节 硬件启动与软件启动

- 提纲
  - RISC-V开发板
  - QEMU启动参数和流程
  - x86启动流程

- RISC-V开发板
  - K210开发板
    - 基于RISC-V 64多核处理器
  - 哪吒D1开发板
    - 基于RISC-V 64单核处理器
  - HiFive Unmatched 开发板（U740）
    - 基于RISC-V 64多核处理器

- QEMU启动参数和流程
  - QEMU模拟器
    - 模拟一台64位RISC-V架构的计算机
      - 包含一个或多个CPU
      - 物理内存
      - 若干I/O外设
  - QEMU启动参数
    - 启动配置示例
      ```
      qemu-system-riscv64 \
          -machine virt \
          -nographic \
          -bios ../bootloader/rustsbi-qemu.bin \
          -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000
      ```
      - machine virt: 设置为名为virt的虚拟机
      - nographic: 不使用图形界面，只输出字符流
      - bios: 设置引导加载程序
      - device loader: 载入文件到指定的物理内存地址
  - QEMU启动流程
    - 启动阶段划分
      1. 固化在QEMU模拟计算机内存中的汇编程序初始化并执行bootloader
      2. Bootloader初始化并加载OS
      3. OS内核执行初始化工作

- x86启动流程
  - 真实计算机(x86)的启动流程
    1. Rom Stage: 在ROM上运行BIOS代码
    2. Ram Stage: 在RAM上运行代码，检测并初始化芯片组、主板等
    3. Bootloader Stage: 在存储设备上找到Bootloader并加载执行
    4. OS Stage: Bootloader初始化外设，在存储设备上找到OS并加载执行

### 第四节 实践：裸机程序 -- LibOS

- 提纲
  - 实验目标和思路
  - 实验要求
  - 实践步骤
  - 代码结构
  - 内存布局
  - 基于 GDB 验证启动流程
  - 函数调用
  - LibOS初始化
  - SBI调用

- LibOS的实验目标
  - 概念：裸机程序（Bare Metal Program）
    - 与操作系统无关的OS类型的程序
  - 功能：
    - 建立应用程序的执行环境
      - 让应用与硬件隔离
      - 简化应用访问硬件的难度和复杂性
    - 提供执行环境（Execution Environment）

- LibOS历史背景
  - 1949-1951年，J. Lyons and Co. 引入EDSAC计算机，联合设计LEO I系统
  - 子程序概念的引入
    - David Wheeler 发明子程序概念 – Wheeler Jump
    - 子程序库形成了最早的操作系统原型

- LibOS总体思路
  - 编译：设置编译器支持裸机程序
  - 构造：建立栈和SBI服务请求接口
  - 运行：OS的起始地址和执行环境初始化

- 实验要求
  - 理解LibOS的执行过程
    - 编写、编译、运行裸机程序
    - 懂得基于裸机程序的函数调用
    - 能看懂汇编代码伪代码和内嵌汇编代码
    - 初步理解SBI调用

- 实践步骤
  - 开发与实验环境准备
  - 移除标准库依赖
  - 支持函数调用
  - 基于SBI服务完成输出与关机
  - 理解程序的内存空间和栈

- 代码结构
  - os/src: 主要代码目录
    - console.rs: 格式化输出实现
    - entry.asm: 设置执行环境的汇编代码
    - lang_items.rs: 包含panic处理逻辑
    - linker-qemu.ld: 控制内核内存布局的链接脚本
    - main.rs: 内核主函数
    - sbi.rs: 调用底层SBI实现提供的接口

- 内存布局
  - .text: 代码段
  - .rodata: 已初始化数据段，只读
  - .data: 可修改的全局数据
  - .bss: 未初始化数据段
  - 堆 (heap) 向高地址增长
  - 栈 (stack) 向低地址增长

- 基于 GDB 验证启动流程
  - 使用GDB连接至QEMU进行调试
  - 分析加载和执行流程

- 函数调用
  - ABI 和 SBI 接口详解
  - 函数调用、返回和寄存器使用约定
  - 栈帧的管理和使用

- LibOS初始化
  - 从ASM到Rust的控制权转交
  - 清空bss段以初始化未分配的全局变量

- SBI调用
  - SBI服务接口
  - SBI服务编号
  -  汇编级SBI调用
  -  SBI调用：输出字符
  -   SBI调用：关机
  -  优雅地处理错误panic
  -  LibOS完整功能

## 第三讲: 基于特权级的隔离与批处理

### 第三讲总结
- 知识点
  	- OS与硬件的关系
    	- OS与硬件的接口/边界
    	- OS对硬件的抽象
    - OS与APP的关系
      - OS与APP的接口/边界
    - 隔离的定义、目标与方法 
  	- 特权级定义
    	- 特权级切换
      - 中断/异常
  	- 系统调用的定义/特征/实现
  		- 系统调用设计与实现
    	- 系统调用执行过程 
  	- RISC-V特权级
      	- U-Mode/S-Mode/M-Mode
        	- 哪些软件/固件适合运行在哪种特权级模式
      	- 控制状态寄存器(CSR)	
        	- scause、sepc、stvec、stval、sstatus、satp
  	- 外设中断
    	- 中断处理过程
      	- RISC-V S-Mode下的中断处理
        	- 硬件直接的中断处理
        	- 软件的中断处理
  	- 软件异常
    	- 异常处理过程
      	- RISC-V S-Mode下的异常处理
        	- 硬件直接的异常处理
        	- 软件的异常处理 
    - 中断、异常、系统调用的异同点
  	- 批处理操作系统的设计与执行
    	- 用户栈与内核栈的切换
    	- sscratch CSR的作用
    	- Trap上下文及其处理过程
    	- 对运行用户态任务的支持







### 第一节 从OS角度看计算机系统
- OS与硬件的关系 
  - 计算机系统
    - 抽象层次的设计
    - 有效使用现有制造技术
    - 信息处理应用
  - 计算机系统抽象层次
    - 硬件支持OS支持应用
    - 操作系统位于硬件和应用之间
  - 指令集：软硬件接口
    - 硬件与OS的边界
    - 指令集+寄存器
  - OS是对硬件的虚拟与抽象
  - RISC-V处理器架构
  - uCore的框架结构
- OS与应用程序的关系
  - OS对应用程序执行的支持
    - 提供服务
    - 系统调用
    - 地址空间布局
  - OS为应用程序提供服务
    - 通过系统调用来提供服务
    - 系统调用是OS/APP的接口
  - 系统调用如何实现？
    - 调用过程
    - 直接或间接调用内核函数问题
  - 引入系统调用的目的
    - 增强安全性和可靠性
    - 函数调用的特征
  - 进程的地址空间
    - 内核页表隔离(KPTI)
- 隔离机制
  - 隔离要解决的问题
    - 防止程序互相破坏或监视
    - 防止进程干扰操作系统
    - 防止恶意程序、病毒、木马和bug
  - 隔离方法
    - 软件、硬件、网络基础隔离
  - OS隔离APP的分类
    - 控制隔离：特权级机制
    - 数据隔离：虚拟内存
    - 时间隔离：中断处理
    - 异常处理
  - 虚拟内存
    - 工作原理
    - 解决的问题
  - 控制隔离：特权模式
    - CPU硬件中的特权模式
    - Kernel Mode vs User Mode
  - 时间隔离：中断/异常机制
    - 中断处理例程
    - 时钟中断
    - 异常处理例程
    - 系统调用处理例程
  - 中断 vs 异常 vs 系统调用
    - 触发者、响应方式、触发机制、处理机制
  - 进程切换 vs 函数切换
    - 比较图解
- 小结
  - 计算机硬件与操作系统的关系
  - 操作系统与应用程序的关系
  - 操作系统如何隔离与限制应用程序
### 第二节: 从OS角度看RISC-V
- 主流CPU比较
  - x86和ARM设计复杂性
    - 兼容性问题
    - 历史遗留问题
  - RISC-V特点
    - 简洁
    - 灵活
    - 可扩展
- RISC-V系统模式
  - 系统模式概述
    - ABI/SBI/HBI
    - AEE/SEE/HEE
    - HAL
    - 虚拟机监视器 (Hypervisor)
  - RISC-V相关术语
    - AEE, ABI, SBI, SEE, HEE, Hypervisor, HBI
  - 不同软件层的隔离支持
  - 单应用场景
    - 应用通过ABI运行在AEE上
  - 操作系统场景
    - 通过ABI与OS通信，OS通过SBI与SEE通信
  - 虚拟机场景
    - 支持多个操作系统
  - 应用场景对比
    - 从小型设备到数据中心服务器
  - 硬件线程和异常处理
    - 特权级保护机制
    - 异常导致自陷
- RISC-V特权级
  - 多个特权级
    - U: User
    - S: Supervisor
    - H: Hypervisor
    - M: Machine
  - 执行环境和跨越特权级
    - 使用ecall和mret等指令
  - 特权级的灵活组合
    - 需求变化下的硬件设计
  - 各模式详解
    - 用户态(U-Mode)
    - 内核态(S-Mode)
    - H-Mode
    - 物理机模式(M-Mode)
- RISC-V CSR寄存器
  - 寄存器分类
    - 通用寄存器
    - 控制状态寄存器 (CSR)
  - 通过CSR实现隔离
    - 权力、时间、数据隔离
  - CSR功能和作用
    - 信息类
    - Trap设置
    - Trap处理
    - 内存保护
- RISC-V系统编程
  - 用户态编程
    - 使用系统调用
    - 示例：hello world
    - 执行特权指令示例
    - 特权操作说明
  - M-Mode编程
    - 中断机制和异常机制
    - 中断/异常硬件响应
    - 中断/异常控制权移交
  - 内核编程
    - S-Mode中断控制和状态寄存器
    - 中断/异常机制
    - 虚存机制
    - 地址转换示例
- 小结
  - RISC-V架构和特权级的理解
  - 硬件与软件的交互方式
  - 软件间如何切换和控制
### 第三节: 实践：批处理操作系统
- 实验目标
  - 让APP与OS隔离
  - 自动加载并运行多个程序
  - 理解特权级和特权级切换
  - 实现系统调用
- 实践步骤
  - 构造包含OS和多个APP的单一执行镜像
  - 通过批处理支持多个APP的自动加载和运行
  - 利用硬件特权级机制实现对操作系统自身的保护
  - 支持跨特权级的系统调用
  - 实现特权级的切换
- 软件架构
  - 构建应用
    - 把多个应用合在一起与OS形成一个二进制镜像
  - 改进OS
    - 加载和执行程序、特权级上下文切换
  - 系统调用设计
    - 设计支持系统调用的库
- 相关硬件
  - RISC-V陷入(trap)类指令
    - ecall 和 ebreak
  - 特权指令
    - sret
  - 异常向量表
    - 描述各种异常类型和代码
- 应用程序设计
  - 应用与底层支撑库分离
  - 引入外部库
  - 设计支撑库
    - 定义用户库的入口点 _start
  - 内存布局
    - 设计应用程序的内存布局
  - 系统调用
    - 应用程序的系统调用执行流
    - 系统调用封装和参数传递
- 内核程序设计
  - 应用管理和加载
    - 将应用程序映像链接到内核
    - 应用程序管理数据结构
    - 加载应用程序二进制码
  - 特权级切换
    - 特权级切换相关CSR
    - 特权级切换后的硬件逻辑
    - 返回用户态让应用执行
  - Trap处理
    - Trap上下文数据结构
    - 保存Trap上下文
    - 调用trap_handler
    - 恢复Trap上下文
  - 执行应用程序
    - 应用程序的执行时机
    - 让应用程序执行
    - 切换到下一个应用程序

## 第四讲 多道程序与分时多任务


### 第四讲总结
- 知识点
  	- 控制流与控制流上下文
    	- 普通控制流与异常控制流
  		- 函数上下文
  		- 中断上下文
  		- 任务上下文
  	- 任务生命周期
  	- 任务执行过程
  	- 调度
    	- 协作式调度
    	- 抢占式调度
      	- 时钟中断的作用
  	- 作业/任务/进程的关系
  	- 进程与程序的区别与关系
  	- 进程控制块
  	- 进程状态及其状态转换
  		- 创建态
  		- 就绪态
  		- 运行态
  		- 阻塞态
  		- 退出态
  	- 进程状态转换与系统调用的关系
  	- 多道程序操作系统的设计与运行过程
    	- 对内存中多程序执行的支持
    	- 应用程序运行的内存布局
    	- 任务上下文及其切换过程
  	- 分时多任务操作系统的设计与运行过程
  		- 对时钟中断的响应和处理



### 第一节: 进程和进程模型
- 多道程序与协作式调度
  - 历史
    - 大型机到小型机的过渡时期
    - OS/360, DEC公司的PDP系列
  - 多道程序概念
    - 内存中存在多个可执行程序
    - 共享处理器
  - 作业(Job)
    - 应用的一次执行过程
  - 协作式调度
    - 程序主动放弃处理器使用
    - 操作系统不会打断正在执行的程序
- 分时多任务与抢占式调度
  - 历史背景
    - 小型机普及，多用户系统需求增加
    - DEC的VMS, MIT的CTSS, AT&T的UNIX
  - 用户视角的分时多任务
    - 各程序分时共享处理器
    - 操作系统按时间片分配CPU时间
  - OS视角的分时多任务
    - 进程: 动态执行过程的程序实例
    - 进程切换
  - 抢占式调度
    - 进程被动地放弃处理器使用
    - 时钟硬件中断使操作系统可以打断程序
- 进程的概念
  - 进程特点
    - 动态性, 并发性, 有限度的独立性
  - 进程与程序的区别
    - 进程是动态且暂时的
    - 程序是静态且永久的
  - 进程状态
    - 包括控制流, 数据, 和管理数据
  - 进程控制块 (PCB)
    - 操作系统管理进程的核心数据结构
- 进程模型
  - 进程状态变迁
    - 创建, 就绪, 运行, 等待, 唤醒, 抢占, 退出
  - 三状态进程模型
    - 就绪, 执行, 阻塞
  - 进程状态变迁与系统调用
    - 涉及系统调用如 exit, sleep 等
  - 进程切换
    - 在任务生命周期中进行任务切换的时机
### 第二节: 实践：多道程序与分时多任务操作系统
- 实验目标和步骤
  - 实验目标
    - MultiprogOS: 提高多个应用的总体性能和效率
    - BatchOS: 让APP与OS隔离，提高安全性和效率
    - LibOS: 让应用与硬件隔离，简化访问硬件的复杂性
  - 实验要求
    - 理解协作式调度和抢占式调度
    - 理解任务和任务切换
    - 能写多道程序操作系统和分时多任务操作系统
  - 实践步骤
    - 编译应用程序和内核为一个镜像
    - 修改APP链接脚本定制起始地址
    - 加载执行应用与切换任务
- 多道批处理操作系统设计
  - 软件架构
    - 应用程序独立编译合并至OS镜像
    - 完善任务管理功能
  - 代码结构
    - 构建应用
    - 改进OS支持任务切换
- 应用程序设计
  - 项目结构
    - 包含编号的应用程序
  - 内存布局
    - 使用build.py工具定制链接脚本
  - yield系统调用
    - 让应用主动放弃处理器
- LibOS：支持应用程序加载
  - 多道程序加载
    - 将应用加载到不同的物理地址
  - 执行程序
    - 内核态到用户态的切换
- BatchOS：支持多道程序协作调度
  - 任务控制块
    - 管理任务运行所需信息
  - 协作式调度
    - sys_yield和sys_exit系统调用
  - 任务切换
    - 暂停一个应用执行过程并继续另一应用
- MultiprogOS：分时多任务OS
  - 基本思路
    - 设置时钟中断和统计时间片
    - 抢占式调度
  - 时钟中断与计时器
    - 设置和处理时钟中断
  - 抢占式调度实现
    - 通过时钟中断进行任务切换
## 第五讲 物理内存管理


### 第五讲总结
- 知识点
  	- 地址
    	- 物理地址
    	- 虚拟地址
  	- 地址空间概念
  	- 内存分配
      	- 静态内存分配
      	- 动态内存分配
      	- 连续内存分配
        	- Best/First/Worst Fit
        	- Buddy System
      	- 非连续内存分配
    - 内存回收
      - 显式内存回收
      - 隐式内存回收
  	- 物理内存管理
      	- 分页机制
        	- 多级页表的设计与实现
        	- 访存异常及其软硬件协同处理过程
  	- 基于地址空间的分时多任务操作系统的设计与执行
  		- 地址空间抽象与OS实践中的Mmeory-Set数据结构/操作的关系
  		- Mmeory-Set数据结构中的MapArea/PageTable的作用
  		- App/OS双页表机制
    		- 跳板机制的设计
    		- Trap上下文的新内容与放置位置
    		- Trap上下文的转换

### 第一节: 地址空间
- 计算机的存储层次
  - 物理地址和逻辑地址
    - 物理地址: 内存芯片级单元寻址
    - 逻辑地址: CPU执行机器指令时使用的地址
    - 线性地址(虚拟地址): 跟逻辑地址类似，无段式管理时与逻辑地址相同
  - 计算机的存储多层结构
    - 从寄存器到磁盘的多层存储结构
  - 操作系统对内存资源的抽象
    - 描述操作系统如何通过不同技术管理内存
  - 内存管理方式
    - 包括重定位、分段、分页、虚拟存储等
  - 存储层次结构示意
    - 展示了计算机中的存储层次结构
- 地址和地址空间
  - 地址空间的定义
    - 物理地址空间、虚拟地址空间、逻辑地址空间
  - 逻辑地址生成
    - 展示逻辑地址是如何生成的
  - 地址生成时机
    - 编译时、加载时、执行时的地址生成
  - 地址生成过程
    - CPU, MMU, 内存间的互动过程
  - 地址检查
    - 展示地址转换过程中的异常情况处理
- 虚拟存储的作用
  - 外存的缓存
    - 虚拟内存作为外存的缓存机制
  - 简化应用编译和加载运行
    - 通过独立地址空间简化编译链接、加载、共享等
  - 保护数据
    - 通过独立地址空间和地址转换机制保护数据
### 第二节: 内存分配
- 内存分配方式
  - 静态内存分配
    - 编译时完成
    - 全局、静态变量和代码所在段
  - 动态内存分配
    - 运行时进行
    - 栈和堆
    - malloc() 和 free() 函数
- 动态内存分配接口
  - malloc()
    - 分配指定大小的连续堆内存
  - free()
    - 释放已分配的堆内存
- 连续内存分配
  - 定义
    - 分配一块不小于指定大小的连续内存区域
  - 动态分区分配
    - 分配可变大小的连续内存块
    - 处理碎片问题
  - 分配策略
    - 最先匹配 (First-fit)
    - 最佳匹配 (Best-fit)
    - 最差匹配 (Worst-fit)
  - 伙伴系统 (Buddy System)
    - 快速分配和释放，避免外碎片
- 非连续内存分配
  - 概念与需求背景
    - 解决大内存块分配和碎片问题
  - 页式存储管理
    - 物理页面和逻辑页面
    - 页表和多级页表
    - 反置页表和段页式存储管理
  - 内存分配示例
    - 应用调用malloc的流程
    - 地址空间的变化和实际操作
### 第三节: 实践：建立地址空间的OS (ASOS)
- 实验目标和步骤
  - 以往目标
    - 提高性能、简化开发、加强安全
  - 实验目标
    - 简化编程，隔离APP访问的内存地址空间
  - 实验要求
    - 理解地址空间、页机制，处理页访问异常
  - 总体思路
    - 综合使用页表机制，特权级切换，地址空间切换
  - 历史背景
    - 虚拟内存技术的起源和发展
- 系统架构
  - 代码结构
    - 用户程序和内核的代码组织
  - RISC-V SV39页机制
    - 页表基址寄存器satp的功能和设置
- 用户视角的地址空间
  - ASOS地址空间
    - 用户与内核地址空间的配置和管理
  - 跳板页
    - 特权级切换和地址空间切换的实现机制
  - 应用的地址空间
    - 应用程序的内存布局和地址空间配置
- 内核管理地址空间
  - 管理物理内存
    - 物理内存的分配与管理策略
  - 建立内核/应用页表
    - 页表的创建和管理
  - 管理地址空间
    - 地址空间的动态管理和优化
- 实现ASOS
  - 启动分页模式
    - 初始化页表和启动页机制
  - 实现跳板机制
    - 解决内核与应用之间的特权级和地址空间切换问题
  - 加载和执行应用程序
    - 应用程序的加载和执行流程
  - 改进Trap处理的实现
    - Trap机制的改进和优化
  - 改进sys_write的实现
    - 系统调用的实现与优化
## 第六讲 虚拟存储管理


### 第六讲总结
- 知识点
  	- 局部性原理
  	- 扩大内存使用的技术  	
      - 覆盖技术
    	- 交换技术
    	- 虚拟存储技术
  	- 虚拟存储基本概念
  	- Page Fault异常
    	- Page Fault异常中硬件直接做的事情
    	- Page Fault异常中OS做的事情
    - 虚拟存储的性能计算公式
  	- 局部页面置换算法的设计思路、执行过程与实际可实现性分析
    	- 最优算法
    	- FIFO算法
    	- LRU算法
    	- Clock算法
    	- Advanced Clock（二次机会）算法
    	- LFU算法
  	- 全局页面置换算法的设计思路、执行过程与实际可实现性分析
    	- 工作集算法
      	- 工作集
      	- 常驻集
      	- 工作集窗口
      	- 工作集大小
    	- 缺页率算法
  	- 内存抖动问题
  	- Belady异常	



### 第一节: 虚拟存储概念
- 虚拟存储技术的需求
  - 需求背景
    - 程序规模增长迅速，内存需求大于可用内存
    - 理想中的存储器特性：大容量、快速度、低成本、非易失性
  - 基本思路
    - 内存不够时，外存来补，使用覆盖、交换和虚拟存储技术
- 覆盖技术
  - 目标
    - 让程序员手动在较小的内存中运行较大程序
  - 基本原理
    - 不同时间段的函数或模块共享一块内存空间
  - 示例与不足
    - 增加编程复杂度和执行时间
- 交换技术
  - 基本思路
    - 操作系统以程序为单位自动换入换出内存
  - 面临的问题
    - 何时发生交换，程序如何重定位
  - 交换区大小建议与技术比较
    - 对比覆盖和交换技术
- 虚拟存储的基本概念
  - 定义与思路
    - 虚拟存储 = 内存 + 外存
  - 局部性原理
    - 程序执行中数据和指令的访问集中在短时间和小区域内
  - 虚拟存储的基本特征
    - 不连续性、大用户空间、部分交换
  - 底层支撑
    - 硬件（MMU/TLB/PageTable）和软件（OS）
- 缺页异常
  - 处理流程
    - 从产生缺页到修改页表项，并重新执行指令
  - 性能考虑
    - 缺页率、写回概率与有效存储访问时间(EAT)
  - 存储位置
    - 交换空间和磁盘文件
### 第二节: 局部页面置换算法
- 页面置换算法的基本概念
  - 功能
    - 选择被置换的物理页面
  - 设计目标
    - 减少缺页次数和换入/换出次数
  - 评价方法
    - 记录并模拟页面访问，统计缺页次数
- 最优页面置换算法 (OPT, optimal)
  - 工作原理
    - 置换在未来最长时间不访问的页面
  - 特征和示例
    - 缺页最少，理想情况下的算法，无法预知未来访问
- 先进先出页面置换算法 (FIFO)
  - 工作原理
    - 选择驻留时间最长的页面进行置换
  - 特征和示例
    - 实现简单，性能较差，可能会有Belady现象
- 最近最久未使用页面置换算法 (LRU, Least Recently Used)
  - 工作原理
    - 选择最长时间没有被引用的页面进行置换
  - 特征和示例
    - LRU是最优算法的一种近似，实现开销大
- 时钟页面置换算法 (Clock)
  - 工作原理
    - 环形链表形式，选择访问位为0的页面进行置换
  - 特征和示例
    - 是LRU和FIFO的折中，实现相对简单
- 改进的时钟页面置换算法
  - 工作原理
    - 类似时钟算法，但跳过修改过的页面以避免频繁写入
  - 特征和示例
    - 减少了写入外存的次数，适用于写操作较多的场景
- 最不常用页面置换算法 (LFU, Least Frequently Used)
  - 工作原理
    - 置换访问频率最低的页面
  - 特征和示例
    - 开销大，可能保留长期不用但曾经频繁访问的页面
- Belady现象
  - 定义
    - 分配的物理页面数增加时，缺页次数反而升高的异常现象
  - 触发条件
    - 使用FIFO等算法时可能触发，因为这些算法与程序访问内存的动态特征矛盾
### 第三节: 全局页面置换算法
- 全局页面置换算法的定义
  - 功能
    - 根据系统整体需求自动调整各进程物理页面数
  - 设计目标
    - 根据进程在不同阶段的内存需求变化动态调整
- 工作集页面置换算法
  - 定义
    - 根据进程的实际运行情况，即时更新其工作集
  - 实现方法
    - 维护一个固定大小的最近访问页面列表
  - 工作集示例
    - 展示不同时刻的工作集变化
- 缺页率页面置换算法
  - 定义
    - 根据缺页率来动态调整进程的物理内存占用
  - 实现方法
    - 监控缺页率，根据设定阈值增减分配给进程的内存页面
  - 缺页率示例
    - 展示不同配置下的缺页率变化
- 抖动问题解释
  - 定义
    - 因为过度的页面置换导致系统性能下降的现象
  - 解决策略
    - 平衡系统载入的进程数量和分配给每个进程的物理页面数
## 第七讲 进程管理与单处理器调度


### 第七讲总结
- 知识点
	- 进程概念
    	- 任务与进程的关系
	- 进程运行状态与进程生命周期
    	- 孤儿进程
    	- 僵尸进程
	- 进程管理
    	- 进程控制块
        	- 进程控制块包含了进程的哪些内容
        	- 进程控制块是进程的唯一标识
    	- 进程切换
      - 相关系统调用与进程运行状态的关系
	- 调度策略/算法
    	- 基本调度策略/算法的设计思路
        	- 评价指标
        	- FCFS
        	- SJF
        	- SRT
        	- HRRN
        	- MQ
        	- MLFQ
      	- 实时调度策略/算法的设计思路
      	- 评价指标
      	- 可调度性概念
      	- 静态优先级调度与动态优先级调度
      	- 实时调度算法
          	- 速率单调调度算法
          	- 最早截止时间优先算法
          	- 最低松弛度优先算法
      	- 优先级反置问题及其解决方案
          	- 优先级继承(Priority Inheritance)策略
          	- 优先级天花板协议（priority ceiling protocol）
	- 支持进程的操作系统的设计与执行
    	- 进程控制块的扩展内容及其含义
    	- 第一个用户态进程的创建过程及该进程的主要功能
    	- 进程管理系统调用的实现及其之间的关系
        	- fork
        	- exec
        	- waitpid
        	- exit

### 第一节: 进程管理
- 进程的基本概念
  - 需求背景
    - 硬件性能提升
    - 开发者和使用者需求增加
  - 进程提供的抽象
    - 独立控制流
    - 私有地址空间
  - 进程的实现和资源视角
    - 数据结构和动态操作
    - 资源占用集合
- 进程管理
  - 系统调用
    - 创建、执行、终止、等待、获取PID
  - 进程控制块 (PCB)
    - 管理进程状态和属性
  - 进程创建和程序加载
    - fork, exec, exit, waitpid 的过程和示例
  - 进程等待与退出
    - wait 和 exit 的实现和影响
- 关于Fork()的思考
  - Fork()的开销和问题
    - 复制代价高，经常接着exec无效复制
  - 重新思考Fork
    - 历史偶然性，不再是最佳设计
### 第二节: 单处理器调度
- 处理机调度概念
  - CPU资源的时分复用
    - 进程切换和处理机调度
  - 调度时机
    - 内核执行调度的条件
  - 调度策略
    - 如何从就绪队列中选择下一个执行进程
  - 处理机资源的使用模式
    - 进程在CPU和I/O操作间交替
- 调度算法
  - FCFS、SJF、SRT和HRRN
    - 简介和特性
  - 时间片轮转算法RR
    - 基本原理和示例
  - MQ、MLFQ和FSS
    - 多级队列、多级反馈队列与公平共享调度
  - 比较调度算法的准则
    - 评价标准如吞吐量、响应时间、公平等
### 第三节: 实时调度
- 实时操作系统
  - 定义
    - 正确性依赖于时间和功能的操作系统
  - 分类
    - 强实时系统
    - 软实时系统
  - 特性
    - 时间约束的可预测性
- 实时调度
  - 速率单调调度算法 (Rate Monotonic, RM)
  - 最早截止时间优先算法 (Earliest Deadline First, EDF)
  - 最低松弛度优先算法 (Least Laxity First, LLF)
- 优先级反置
  - 定义
    - 高优先级进程因等待低优先级进程释放资源而延迟执行
  - 解决方案
    - 优先级继承
    - 优先级天花板协议
### 第四节: 实践：支持进程的操作系统 (POS)
- 实验目标和步骤
  - 以往目标
    - 提高性能、简化开发、加强安全
  - 实验目标
    - 整合特权级、地址空间、任务成进程
    - 进程成为资源的拥有者
    - 扩展进程动态特征，支持动态创建子进程等
  - 实验要求
    - 理解进程概念和管理机制
    - 初步认识进程调度
    - 掌握shell应用的编写与使用
  - 总体思路
    - 包括编译、构造、运行阶段的详细步骤
- 代码结构
  - 改进OS
    - 包括修改的文件和新增功能
  - 核心数据结构
    - 描述与进程相关的核心数据结构
  - 应用的链接与加载支持
    - 实现基于应用名的应用加载
- 应用程序设计
  - 理解进程
    - 进程是正在执行的应用
  - 进程管理系统调用
    - 包括 fork, exec, exit, waitpid 的实现
  - 应用 shell
    - 执行流程和系统调用交互
- 内核程序设计
  - 创建初始进程
    - 初始化第一个用户态进程 `initproc`
  - 进程管理机制实现
    - 包括创建、切换、调度、回收等过程
  - 进程的链接与加载支持
    - 详细介绍如何加载并执行应用
  - 核心数据结构
    - 详细介绍进程控制块、进程管理器等结构
  - 进程管理机制实现
    - 实现进程的创建、执行、调度和资源回收
## 第八讲 多处理器调度


### 第八讲总结
- 知识点
  	- 处理器架构
    	- 单核
    	- 超线程（Hyperthread）
    	- 多核（multi-core）
    	- 众核（many-core）
    	- 对称多处理器（SMP）
    	- 非一致内存访问系统（NUMA）
  	- Cache 一致性 (Cache Coherence)
    	- Cache 一致性问题
    - 多处理器调度算法
      - 单队列多处理器调度 (SQMS)
      - 多队列多处理器调度 (MQMS)
  	- 负载迁移技术
    	- 工作窃取 (work stealing)


### 第一节: 对称多处理与多核架构
- 处理器架构
  - 单核处理器
  - 超线程 (Hyperthread, Simultaneous multithreading) 处理器
      - 将CPU内部暂时闲置处理资源充分调动起来
      - 寄存器、程序计数器独立
      - 算术计算单元等硬件共用
      - 不适合计算密集型任务
      - 适合IO密集型任务
  - 多核 (multi-core) 处理器
  - 众核 (many-core) 处理器
  - 对称多处理器 (SMP) 
  - 非一致内存访问系统 (NUMA)
- Cache 一致性 (Cache Coherence)
  - Cache 一致性问题
    - 多个处理器可能会同时访问相同的内存位置，而每个处理器可能有自己的缓存。如果不同处理器的缓存中存储了同一内存地址的不同副本，那么就可能出现数据不一致的情况。

### 第二节: 多处理器调度概述
- 单队列多处理器调度 (SQMS)
  - 基本架构
    - 复用单处理器调度下的基本架构
    - 所有需要调度的进程放入一个队列中
  - 特征
    - 缺乏可扩展性 (scalability)
    - 缓存亲和性 (cache affinity) 弱

- 多队列多处理器调度 (MQMS)
  - 基本架构
    - 基本调度框架包含多个调度队列，每个队列可用不同的调度规则
    - 每个 CPU 调度相互独立，避免单队列方式的数据共享及同步问题
  - 特征
    - 具有可扩展性：队列的数量会随着CPU 的增加而增加
    - 具有良好的缓存亲和度：所有进程都保持在固定的 CPU 上
  - 多处理器调度的亲和度与负载均衡
    - 尽可能让进程在同一个 CPU 上运行
    - 保持一些进程的亲和度的同时，可能需要牺牲其他进程的亲和度来实现负载均衡
  - 多队列多处理器调度的负载不均
    - 例子：假定4个进程，2个CPU；队列都执行轮转调度策略；进程C执行完毕，A 获得了 B 和 D 两倍的 CPU 时间
  - 如何解决MQMS的负载不均？
    - 假定 4 个进程，2 个 CPU；每个队列都执行轮转调度策略；A 和 C 都执行完毕，系统中只有 B 和 D
      - CPU1 很忙
      - CPU0 空闲
- 进程迁移 (migration)
  - 优点：通过进程的跨 CPU 迁移，可实现负载均衡
  - MQMS如何确定进程迁移时机?
    - 不断地迁移和切换一个或多个进程
  - MQMS的工作窃取 (work stealing)
    - 策略：进程量较少的 (源) 队列不定期地“偷看”其他 (目标) 队列是不是比自己的进程多。如果目标队列比源队列 (显著地) 更满，就从目标队列“窃取”一个或多个进程，实现负载均衡
    - 工作窃取的队列检查间隔
      - 如果频繁地检查其他队列，就会带来较高的开销，可扩展性不好
      - 如果检查间隔太长，又可能会带来严重的负载不均

## 第九讲 文件系统


### 第九讲总结
- 知识点
	- 文件系统基本概念
    	- 文件
        	- 文件控制块
        	- 文件中的数据
    	- 目录
        	- 目录项
     	- 文件描述符
         	- 打开的文件
         	- 打开文件描述符表
    	- 文件别名
        	- 软链接
        	- 硬链接
    	- 虚拟文件系统
      - 文件访问控制
	- 文件系统设计与实现
		- 文件系统总体结构
		- 文件相关系统调用的设计与执行
    		- open
    		- close
    		- read
    		- write
		- 链式/索引文件结构设计
		- 空闲磁盘块空间管理
		- 缓冲区管理
  - 支持崩溃一致性的文件系统 
      - 崩溃一致性问题
      - 崩溃场景分析
      - 数据日志（data journaling）
      - 元数据日志（Metadata Journaling）
  - 实践：支持文件的操作系统
  	- OS对EasyFS文件系统的支持：数据结构&执行流程
  	- EasyFS文件系统的设计与实现：数据结构&执行流程
  	- 进程与文件系统之间的关联关系：数据结构&执行流程
    - 应用至库至设备驱动的完整文件访问过程


### 第一节 文件和文件系统

- 文件的概念
  - 文件是具有符号名的字节序列构成的数据项集合
  - 文件控制块/文件头部：包含文件属性如名称、类型、位置、创建时间等
- UNIX设计的哲学理念
  - 一切都是文件，提供统一接口，方便应用程序调用
    - 普通文件，目录文件
    - 字符设备文件
    - 块设备文件
    - 网络文件（socket）
- 站在使用者的角度看文件
  - 文件视图
    - 用户的文件视图：持久的数据结构，系统调用接口看作字节序列集合
    - 操作系统的文件视图：数据块的集合
    - 目录是一种特殊的文件，目录下包含文件或子目录
  - 文件中数据的内部结构
    - 与操作系统无关：字节流
    - 与应用相关：无结构文本；简单结构：格式化文件；复杂结构如Word或ELF
  - 文件操作
    - 基本操作：读文件、写文件
      - 进程读文件：获取数据块，返回对应部分
      - 进程写文件：修改数据块中对应部分，写回数据块
    - 其他操作：打开文件、关闭文件、重命名文件、搜索、创建、删除、列目录等
  - 文件的访问模式
    - 顺序访问：按字节依次读取
    - 随机访问：从任意位置读写
    - 索引访问：基于数据特征索引
  - 安全：文件访问控制
    - 访问控制列表 (ACL)
      - 用户对文件的读、写、执行、删除权限
    - UNIX模式：使用者：用户|组|所有人 与 访问权限： 读|写|可执行的组合
  - 共享：多进程如何同时访问共享文件？
    - 文件是共享资源，需要互斥访问，例如使用读写锁
- 站在创造者的角度看文件
  - 进程对文件的管理
    - 文件描述符
      - 文件描述符是指向进程的打开文件描述符表的索引值
      - 应用打开文件后，获得文件描述符--fd，通过fd进行文件读写
      - 应用关闭文件时，释放文件描述符 
    - 打开文件描述符表
      - 用于维护进程打开的所有文件
      - 包含：打开文件的状态和信息，如文件指针、打开计数、文件磁盘位置、访问权限
  - 文件系统对文件的管理
    - 文件系统类型：磁盘文件系统、网络/分布式文件系统、特殊文件系统
    - 虚拟文件系统（VFS）
    - 文件系统功能：管理持久性数据，提供文件命名、存储和检索
      - 分配文件磁盘空间，管理文件集合，数据可靠和安全
      - 文件系统挂载：文件系统需先挂载才能被访问
    - 文件系统组织形式：分层文件系统，目录是特殊文件，包含文件索引表
      - 目录
        - 目录操作：搜索、创建、删除、列目录、重命名文件
        - 目录实现：文件名线性列表或哈希表
      - 文件别名：硬链接和软链接
        - 硬链接：多个文件项指向一个文件
        - 软链接：新建文件存储文件名称指向其他文件


### 第二节 文件系统的设计与实现
- 文件系统的总体结构
  - 文件系统在内核架构中的位置
    - 向下对接存储设备驱动程序
    - 向上提供文件系统接口给进程管理和内存管理
  - 文件系统在操作系统中的静态分层结构（自上而下）
    - 文件相关的系统调用接口
    - 进程管理/内存管理
      - 文件描述符和打开文件描述符表
      - 文件锁
      - 虚存对应的文件
    - 虚拟文件系统（VFS）
      - 定义了一组所有文件系统都支持的数据结构和标准接口
      - 虚拟文件系统统一不同文件系统的访问接口
      - 功能：提供相同的文件和文件系统接口，管理所有文件和文件系统关联的数据结构，高效查询例程，与特定文件系统模块的交互 
    - 具体文件系统（如Fat32、NTFS、ext4）
    - 存储数据缓冲区
    - 存储设备驱动程序
  - 文件系统在操作系统中的动态分层视图（通过write函数自上而下分析）
    - 用户空间的应用程序：write()
    - 用户空间库中的系统调用：sys_write()
    - 内核空间的进程控制块：sys_write()
      - 根据文件描述符--fd，查找打开文件描述发表--fdtable，得到对应的文件控制块--inode
    - 内核空间的虚拟文件系统：sys_write()
      - 根据文件控制块--inode，查找对应的具体文件系统--xxFS，发起对文件的写操作。
    - 内核空间的具体文件系统：xxFS_write()
      - 定位到文件数据对应的存储设备数据块；
      - 发起存储设备数据块写操作。
    - 内核空间的存储设备驱动程序：xxDISKdrv_write()
  - 文件系统分区
      - 磁盘可划分为一个或多个分区
      - 每个分区有一个独立的文件系统
- 文件系统的具体设计
  - 文件系统基本数据结构
    - 文件系统控制块 (`superblock`)
      - 文件系统详细信息：块总量、空闲块数量等
    - 文件控制块 (`index node，简称inode`)
    - 文件数据块 (`data block，data node，简称dnode`)
      - 目录文件的数据块：包含目录项 (`dir_entry`)
    - bitmap块
      - bitmap for inode集合
      - bitmap for dnode集合
  - 文件缓存
    - 多种磁盘缓存位置
    - 数据块缓存
    - 虚拟页式存储与页缓存
  - 文件分配
    - 文件大小：大多数文件小，一些文件非常大
    - 分配方式：连续、链式、索引
  - 空闲空间管理
    - 位图、链表、索引
  - 文件访问过程示例
    - 文件系统组织示例：superblock、inodes、dnodes、bitmaps
      - 下面的例子中忽略了对superblock的修改，因为相关superblock的操作一般是在文件系统挂载或卸载时做的。
    
    - 打开已有文件&读操作过程：open("tmp/file"); read();read();read();
      - 1: open("tmp/file") for reading;
        - 1: inodes: read root DIR; 
        - 2: dnodes: read root DIR; 
        - 3: inodes: read tmp DIR;
        - 4: dnodes: read tmp DIR;
        - 5: inodes: read file metadata;
      - 2: read();
        - 6: inodes: read file metadata;
        - 7: dnodes: read file contents; 
        - 8: inodes: write file metadata(e.g. read time);
      - 3: read();
        - 9: inodes: read file metadata;
        - 10: dnodes: read file contents; 
        - 11: inodes: write file metadata(e.g. read time);
      - 4: read();
        - 12: inodes: read file metadata;
        - 13: dnodes: read file contents; 
        - 14: inodes: write file metadata(e.g. read time);
    - 打开创建文件&写操作过程：open("tmp/file"); write();
      - 1: open("tmp/file") for creating & writing;
        - 1: inodes: read root DIR; 
        - 2: dnodes: read root DIR; 
        - 3: inodes: read tmp DIR;
        - 4: dnodes: read tmp DIR;
        - 5: bitmaps: read inode bitmap;
        - 6: bitmaps: write inode bitmap;
        - 7: inodes: write(create) file's inode;
        - 8：dnodes：write tmp dir_entry；
        - 9：inodes：write tmp's inode;
      - 2: write(); //just one data block
        - 10：inodes：read file's inode;
        - 11: bitmaps：read data bitmap;
        - 12：bitmaps：write data bitmap;
        - 13：dnodes：write file contents;
        - 14：inodes：write file's inode;


### 第三节 支持崩溃一致性的文件系统

- 崩溃一致性问题
  - 文件数据不一致
    - 更新持久数据结构时可能遇到的断电或系统崩溃导致数据不一致
  - 崩溃一致性需求
    - 目标：将文件系统从一个一致状态原子地变迁到另一个一致状态
    - 困难：磁盘一次只提交一次写入，更新之间可能会发生崩溃或断电。
  - 文件更新过程示例
    - 一个应用以某种方式更新磁盘结构：将单个数据块附加到原有文件。
      - 1：调用lseek()将文件偏移量移动到文件新的末尾
      - 2：调用write()向文件发出单个4KB写入来完成数据更新的追加
      - 在上述过程间或过程中可能发生断电
    - 简化的文件系统结构
      - inode位图（inode bitmap，只有8位，每个inode一个）
      - data位图（data bitmap，也是8位，每个数据块一个）
      - inode（总共8个，编号为0到7，分布在4个块上）
      - data（总共8个，编号为0～7）
    - 一般正常情况下的数据更新操作
      - 需对磁盘执行3次单独写入：inode（I[v2]）、data bitmap（B[v2]）和data（Db）
      - 发出write()系统调用时，这些写操作通常不会立即发生。脏的inode、位图和新数据先在内存（页面缓存page cache，或缓冲区缓存buffer cache）中存在一段时间。
      - 当文件系统最终决定将它们写入磁盘时，文件系统将向磁盘发出必要的写入请求。
    - 文件操作中的崩溃场景
      - 1：只将数据块（Db）写入磁盘
      - 2：只有更新的inode（I[v2]）写入了磁盘
      - 3：只有更新后的位图（B [v2]）写入了磁盘
      - 4：inode（I[v2]）和位图（B[v2]）写入了磁盘，但没有写入数据（Db）
      - 5：写入了inode（I[v2]）和数据块（Db），但没有写入位图（B[v2]）
      - 6：写入了位图（B[v2]）和数据块（Db），但没有写入inode（I[v2]）
- 文件系统检查程序 fsck
  - 解决崩溃一致性问题的方法之一
  - 详细检查过程包括超级块检查、位图与inode间的一致性检查等
  - 检查和修复文件系统使其达到内部一致状态
- 日志文件系统
  - 使用日志（预写日志）来保证文件系统的崩溃一致性
    - 更新磁盘时，在覆写结构之前，首先写下一点小注记（在磁盘上的其他地方，在一个众所周知的位置），描述你将要做的事情。写下这个注记就是“预写”部分，把它写入一个结构，并组织成“日志”。
    - 发生崩溃时，能够返回并查看你所做的注记，从而能准确知道要修复的内容（以及如何修复它），然后重试。
  - 数据日志操作
    - 文件更新
      - 日志写入 Journal write：
        - 将事务的内容（包括TxB、元数据和数据）写入日志，等待这些写入完成。
      - 日志提交 Journal Commit：
        - 将事务提交块（包括TxE）写入日志，等待写完成，事务被认为已提交（committed）。
      - 加检查点 Checkpoint
        - 将更新内容（元数据和数据）写入其最终的磁盘位置。
    - 崩溃恢复
      - 崩溃发生在Journal Commit完成前：文件系统可以丢掉之前写入的log。
      - 崩溃发生在Checkpoint完成后：不用做事。
      - 崩溃发生在Journal Commit后，Checkpoint之前：根据已经commited的log记录信息执行Checkpoint操作。
  - 元数据日志操作：**数据+元数据日志 --> 元数据日志**
    - 文件更新
      - Data write：写入数据到磁盘的对应位置
      - Journal metadata write：将TxB以及对应的文件metadata操作写入到事务中
      - Journal commit：写入TxE，并等待完成。完成后，这个事务是committed。
      - Checkpoint metadata：将事务中的metadata的操作相关数据，分别各自回写到各自的磁盘位置中。
      - Free：释放journal区域的log记录
      - 注：通过强制首先写入数据，文件系统可保证指针永远不会指向垃圾数据。



### 第四节 实践：支持文件的操作系统 (Filesystem OS)

- 实验目标
  - 当前实验目标：支持数据持久保存
  - 以文件形式保存持久数据，并进行文件数据读写
  - 进程成为文件资源的使用者
  - 系统调用：open/read/write/close
- 实验要求
    - 理解文件系统/文件概念
    - 理解文件系统的设计与实现
    - 理解应用至库至设备驱动的完整文件访问过程
    - 能编写支持文件系统的OS
- 需要考虑的问题
    - 文件系统在硬盘上如何组织？硬盘布局？
    - 如何管理空闲磁盘块？
    - 文件/目录的表示方法？
    - 文件/目录数据内容的表示？
    - 如何访问一个文件？
- 总体思路
    - 存储设备上的文件系统和文件
    - OS管理的内存中的文件系统和文件
    - 二者的关联关系
- 文件系统接口和数据结构
    - 文件访问流程图
      - 初始化：文件系统，磁盘外设
      - 初始化：确定文件系统根节点
      - 对用户进程的服务：根据文件名，从根节点出发，找到目录项和对应的inode
      - 对用户进程的服务：根据inode进行文件读写  
    - 文件系统访问接口（自上而下）
      - syscall interface
      - 进程：fd_table interface
      - VFS
      - easyfs
      - BlkCacahe
      - BlkDriver
    - 文件系统的数据结构
      - PCB: fd_table[fd] --> OSInode 
      - VFS：OSInode --> DiskInode
      - EasyFS：DiskInode --> BlkCache
      - BlkCache：BlkCache --> BlkDevice
      - BlkDevice：read_block()/write_block() --> Disk
- 实验步骤
    - 编译：内核独立编译，单独的内核镜像
    - 编译：应用程序编译后，组织形成文件系统镜像
    - 构造：进程的管理与初始化，建立基于页表机制的虚存空间
    - 构造：构建文件系统
    - 运行：特权级切换，进程与OS相互切换
    - 运行：切换地址空间，跨地址空间访问数据
    - 运行：从文件系统加载应用，形成进程
    - 运行：数据访问：内存--磁盘，基于文件的读写
- 代码结构
    - 分析新增和改进的模块
      - easy-fs和其构成
      - OS中与文件/文件系统相关的修改部分
        - 与加载文件相关的修改
      - 存储块设备驱动（基本了解其功能即可）
- 应用程序设计
    - 文件和目录
      - 从应用和内核两个角度来理解
    - 文件访问系统调用：open, close, read, write
      - 从进程和文件系统两个角度来理解
      - 从进程和文件系统二者在文件访问上的联系来分析
- 内核程序设计
    - 核心数据结构
      - 进程管理文件
        - DirEntry
        - OSInode
        - fd_table
      - 文件系统管理 
        - superblock
        - inode/data bitmap
        - disk_inode
        - disk_data
        - blk_cache
    - 文件管理机制
      - 文件系统初始化
      - 基于文件加载应用
      - 打开/关闭文件
      - 读/写文件



