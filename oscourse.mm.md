# OS-Course Slides <!-- markmap: foldAll --> 

## 第一讲 操作系统概述

### 第一讲总结
- 知识点
	- 操作系统定义
		- 操作系统是**管理硬件资源**、控制程序运行、改善人机界面和**为应用软件提供支持**的一种系统**软件**
	- 内核基本抽象
		- 进程 -- CPU
		- 文件 -- 存储(I/O)设备
		- 地址空间 -- 内存(+存储)
	- 内核特征
		- 并发
		- 共享
		- 虚拟
		- 异步 
	- 内核演进
		- 批处理系统
		- 多道程序系统
		- 分时系统
				- CTSS
				- Multics
				- UNIX + C -- Ken Thompson + Dennis Ritchie
				- Linux	使用最广泛的OS
				- Android with Linux kernel
	- 内核架构
		- 简单结构 -- DOS
		- 单体分层结构（宏内核） -- UNIX
		- 微内核 -- Mach、seL4、MINIX
		- 外核 -- exokernel from MIT，演进为虚拟机管理器 VMM or Hypervisor  
	- 实践能力
		- 会使用基本Linux命令: ls、rm、gcc、gdb、make、git、ps、cat
		- 了解Linux基本系统调用：fork、exit、wait、kill、getpid、sleep、exec、sbrk、open、write、read、close、dup、pipe、chdir、mkdir、mknod、fstat、stat、link、unlink
		- 理解、编译、运行Linux程序：fork.c、exec.c、forkexec.c等




### 第一节 课程概述 & 教学安排
- [课程幻灯片列表](https://www.yuque.com/xyong-9fuoz/qczol5/ewvhdy3epbwbkn3n)
- 课程信息
    - 主讲教师：向勇 陈渝 李国良 任炬
    - 助教：饶淙元、田凯夫、闭浩扬、王拓为、苏明贤、黄旺、郝子胥
- 上课信息
    - 上课时间地点
    - 时间：星期一 第2大节 上午09:50-12:15 (1-16周) 
    - 地点：六教6A209（任）六教6A211（李）六教6A213（陈）
- 预备知识
    - 程序设计语言（汇编、C 和 Rust）
    - 不是开发应用程序 :confounded:
    - 而是开发系统程序 :smile:
    - 数据结构
    - 理解基本数据结构即可 :smile:
    - 计算机组成原理
    - 刘总/康总/陆总的 RISC-V 原理 :smile: :smile: :smile:
    - Patterson 的 RISC-V 原理 :smile:
    - 编译原理
    - 没学过影响不大 :smile:
    - 但还是要了解高级语言 <–>RISC-V 汇编语言 :smile:
- 课程参考与实践
    - [课程幻灯片](https://www.yuque.com/xyong-9fuoz/qczol5/ewvhdy3epbwbkn3n)
    - 参考书籍
    - [Operating Systems: Three Easy Pieces](https://pages.cs.wisc.edu/~remzi/OSTEP/)
    - [深入了解计算机系统](https://hansimov.gitbook.io/csapp/)
    - [RISC-V Reader中文版](http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf)
    - 课程实践
    - [rCore Tutorial Book v3](https://learningos.github.io/rCore-Tutorial-Book-v3/)
    - [代码仓库](https://github.com/rcore-os/rCore-Tutorial-v3)
    - [API文档](https://github.com/rcore-os/rCore-Tutorial-v3#os-api-docs)
- 实验指导
    - uCore Tutorial
    - [实验代码](https://github.com/LearningOS/uCore-Tutorial-Code-2024S/)
    - [实验文档](https://learningos.github.io/uCore-Tutorial-Guide-2024S/)
    - [测试用例](https://github.com/LearningOS/uCore-Tutorial-Test-2024S/)
    - rCore Tutorial
    - [实验文档](https://learningos.github.io/rCore-Tutorial-Guide-2024S/)
    - [API文档](https://github.com/LearningOS/rCore-Tutorial-Guide-2024S/#os-api-docs-of-rcore-tutorial-code-2022a)
    - [实验代码](https://github.com/LearningOS/rCore-Tutorial-Code-2024S)
    - [测试用例](https://github.com/LearningOS/rCore-Tutorial-Test-2024S)
    - [uCore和rCore实验帮助](https://www.yuque.com/xyong-9fuoz/qczol5/lt5qafszpz62hob1?singleDoc)
    - 讲解视频
    - 部分内容将逐步更新
- OS 原理与设计思想
    - 操作系统结构
    - 中断及系统调用
    - 内存管理
    - 进程管理
    - 处理机调度
    - 同步互斥
    - 文件系统
    - I/O 子系统
- 作业与实验
    - 平时作业
    - 课后练习：包括问答题和编程题目，要求在deadline前提交
    - 基础实验
    - （必做）面向 RISC-V CPU 用 Rust/C 设计实现操作系统的功能
    - （选做）难度和工作量比必做题目大的其它题目
    - 课程设计（大实验）
    - 用组件来组合操作系统内核
    - 参加全国大学生OS比赛
- 基础实验详细内容
    - 实验一：操作系统的基本支持
    - 实验二：地址空间
    - 实验三：进程管理与调度
    - 实验四：文件系统与进程间通信
    - 实验五：同步互斥
- 课程设计（大实验）
    - 用组件来组合操作系统内核
    - 组件化操作系统[ArceOS](http://arceos.org/overview.html)
    - 操作系统功能和扩展
    - 内核模块的完善和改进
    - 内核可加载模块、微内核、在内核中引入异步编程
    - 支持多种处理器架构和硬件平台
    - GUI、驱动、文件系统、网络
    - 往届同学的[课程设计成果](https://shimo.im/docs/QTPRT8h8jyGQCqkJ)
- 成绩评定
    - 选择1
    - 实验一~五必做题目：40%
    - 期中考试：20%
    - 期末考试：40%
    - 加分：平时作业每做一次加1分，最高加5分
    - 选择2
    - 四周内完成实验一~五：40%
    - 课程设计（即大实验）：60%
- 调查问卷
    - [2024年春季学期操作系统课选课问卷](http://oscourse2019.mikecrm.com/TdGsawl)

### 第二节 什么是操作系统
- 操作系统定义
  - 没有公认的精确定义
  - 功能
    - 管理硬件资源
    - 控制程序运行
    - 改善人机界面
    - 为应用软件提供支持
  - 描述来源: [计算机百科全书]

- 操作系统的角色
  - 资源管理程序
    - 应用与硬件之间的中间层
    - 管理各种软硬件资源
    - 提供访问软硬件资源的服务
    - 解决访问冲突，确保公平使用
  - 控制程序
    - 执行程序，给程序提供服务
    - 控制程序执行过程，防止错误
    - 方便用户使用计算机系统

- 操作系统的软件分类
  - Shell: 命令行接口
  - GUI: 图形用户接口
  - Kernel: 操作系统的内部

- uCore/rCore 教学操作系统内核
  - 内核结构图展示

- 操作系统内核的抽象
  - 内核抽象图展示

- 操作系统内核的特征
  - 并发: 多个程序同时运行
  - 共享: 程序间“同时”访问互斥共享资源
  - 虚拟: 每个程序“独占”一台完整计算机
  - 异步: 服务完成时间不确定，可能失败

- 对操作系统内核的理解
  - 用户/应用对操作系统的需求
    - 高效性 vs 易用性
    - 强大的操作系统服务 vs 简单的接口
    - 灵活性 vs 安全性

- 为什么要学习这门课程
  - 了解计算机机壳后面的软硬件运行原理
  - 学习软硬件基础架构和原理
  - 深入了解程序运行机理
  - 发现并修复难以对付的bug
### 第三节 操作系统历史演化
- 操作系统的历史发展
  - 单用户系统 (1945-1955)
      - 手动连线/纸带传输进行程序输入
      - 机器成本远大于人力成本
      - 操作系统 = 装载器 + 程序库
      - 问题：昂贵组件的低利用率
  - 批处理系统 (1955-1965)
      - 磁带/磁盘传输进行程序输入
      - 操作系统 = 装载器 + 程序控制器 + 输出处理器
      - 问题：相比以前利用率提高
  - 多道程序系统 (1955-1980)
      - 多个程序驻留内存中
      - 多个程序轮流使用 CPU
      - 操作系统 = 装载器 + 程序调度 + 内存管理 + 输出管理
      - 演变：相比以前利用率提高
  - 分时系统 (1970-至今)
      - 多个程序分时使用 CPU
      - 操作系统 = 装载器 + 程序调度 + 内存管理 + 中断处理
      - 演变：利用率提高、交互延时缩短

- 操作系统家族和影响
  - Multics OS
      - 高级别安全和多用户操作系统
  - UNIX（Ken Thompson 与 Dennis Ritchie）
      - 开放系统，多用户支持
  - Linux家族
      - 开源和自由软件运动的产物
  - 个人电脑 (1981- )
      - 单用户
      - 重点是用户界面和多媒体功能
      - 操作系统 = 装载器 + 程序调度 + 内存管理 + 中断处理
      - 演变：走向大众，老的服务和功能不存在，越来越多的安全问题
  - MacOS家族
      - 基于UNIX的图形界面系统
  - Windows家族
      - 微软开发，主导个人计算市场

- 特定领域操作系统
  - 分布式系统 (1990- )
      - 分布式多用户
      - 重点是网络/存储/计算的效率
      - 操作系统 = 分布式（装载器 + 程序/OS 调度 + 内存管理）
      - 演变：走向网络，新的挑战（不可靠/不确定性）
  - Android操作系统
      - 跨平台：支持Java应用程序
      - 运行时：Android虚拟机
      - 应用框架：简化应用程序开发
  - AIoT操作系统
      - 分布式多设备
      - 重点是网络/存储/计算的效率
      - 操作系统 = 分布式（程序/OS 调度 + 内存管理 + 安全/更新）
      - 演变：走向设备，走向网络，新的挑战（不可靠/大数据）

### 第四节 操作系统结构
- 操作系统的不同结构
  - 简单结构
      - MS-DOS：应用和OS混在一起 (1981–1994)
      - 没有拆分为模块
      - 主要用汇编编写
      - 没有安全保护
      
  - 单体分层结构
      - 将单体操作系统划分为多层
      - 每层建立在低层之上
      - 最底层 (layer 0) 是硬件驱动
      - 最高层 (layer N) 是用户界面
      - 每一层仅使用更低一层的功能和服务

  - 微内核结构 (Micro Kernel)
      - 尽可能把内核功能移到用户空间
      - 用户模块间通信使用消息传递
      - 好处: 灵活、安全...
      - 缺点: 性能问题
      - LPC: 本地过程调用
      - HAL: 硬件抽象层

  - 外核结构 (Exokernel)
      - 内核分配物理资源给多个应用程序
      - 让每个程序决定如何处理这些资源
      - 程序能链接到操作系统库 (libOS) 实现了操作系统抽象
      - 保护与控制分离
      - Distributed Shared Memory (DSM)

  - 虚拟机结构
      - 虚拟机管理器将单独的机器接口转换成很多的虚拟机
      - 每个虚拟机都是一个原始计算机系统的有效副本
      - 能完成所有的处理器指令

- 应用程序运行与 OS 抽象 + 架构的关系
  - 说明了应用程序在不同操作系统架构中的运行方式与OS提供的环境和抽象的关系

### 第五节 实践：试试UNIX/Linux
- UNIX/Linux 系统介绍
    - 常见的Linux发行版
    - Ubuntu、Fedora、SuSE、openEuler
    - 麒麟、统信
    - 其他系统支持
    - Windows with WSL (Windows Subsystem for Linux)
    - MacOS with UNIX shell

- UNIX/Linux的特点
    - 开放源码，有很好的文档，设计简洁，使用广泛
    - 对学习ucore/rcore内部情况有帮助

- 尝试使用UNIX/Linux
    - Shell环境
    - bash: 基本的shell环境
    - fish: 强调交互性和可用性
    - zsh: 带有自动补全、支持插件
    - starship: 轻量、迅速、可无限定制
    - 常用程序
    - ls, rm，gcc，gdb, vim

- UNIX/Linux提供的服务
    - 进程（正在运行的程序）
    - 内存分配
    - 文件内容、文件名、目录管理
    - 访问控制（安全）
    - 其他服务：用户、IPC、网络、时间

- UNIX/Linux的应用/内核接口
    - 通过系统调用与内核交互
    - 示例: `fd = open("out", 1); write(fd, "hello\n", 6);`
    - 系统调用示例：
    - `int fork()` 创建一个进程，返回子进程的PID
    - `int exit(int status)` 终止当前进程；没有返回
    - `int wait(int *status)` 等待子进程退出；返回子进程的PID
    - `int kill(int pid)` 终止进程号为PID的进程；返回0或-1表示错误
    - `int getpid()` 返回当前进程的PID
    - 更多系统调用：`sleep`, `exec`, `sbrk`, `open`, `write`, `read`, `close`, `dup`, `pipe`, `chdir`, `mkdir`, `mknod`, `fstat`, `stat`, `link`, `unlink`

- UNIX/Linux应用分析
    - 查看和分析简单小程序
    - 进程相关：fork.c, exec.c, forkexec.c
    - 文件系统相关：list.c, open.c, echo.c, copy.c
    - 进程间通信相关：pipe1.c, pipe2.c, redirect.c

## 第二讲 实践与实验介绍

### 第二讲总结
- 知识点
	- 函数调用、栈帧与参数
	- 编译器/硬件与OS之间的共识
	- 加电后硬件/软件启动过程
	- 程序执行过程
	- Linux应用编程
	- 裸机编程
	- RISC-V的SBI
	- 开发环境与执行环境
	- LibOS的设计与执行






### 第一节 实践与实验简要分析
- 提纲
  - 原理、实践与实验介绍
  - 循续渐进的操作系统实验
  - 实验安排

- 操作系统需求逐渐增加
  - LibOS
  - 批处理OS
  - 多道程序与分时多任务OS

- 逐步体现操作系统概念抽象
  - 地址空间抽象的OS
  - 进程抽象的OS
  - 文件抽象的OS

- 逐步体现操作系统关键能力
  - 可进程间通信的OS
  - 可并发的OS
  - 管理I/O设备的OS

- 具体操作系统类型和特点
  - LibOS
      - 远古操作系统雏形
      - 现代简单嵌入式操作系统
      - 相关知识点:
      - 以库的形式提供给应用程序的OS
      - 函数调用: 编译器与操作系统的配合
      - 硬件启动和软件启动
      - 编写/调试裸机程序

  - 批处理OS
      - 内存只驻留单道程序
      - 支持系统调用
      - 相关知识点:
      - 特权级/特权操作
      - RISC-V特权级/特权操作
      - 系统调用/异常
      - 加载&执行&切换应用程序
      - 特权级切换

  - 多道程序OS
      - 支持多个程序同时驻留内存
      - 支持多个程序依次执行
      - 相关知识点:
      - 内存空间划分与管理
      - 协作式调度

  - 分时多任务OS
      - 支持多个程序轮流执行
      - 相关知识点:
      - 中断处理
      - 上下文切换
      - 抢占式调度

- OS的地址空间抽象
    - 支持程序间内存空间隔离
    - 超越物理内存的虚拟存储
    - 相关知识点:
    - 地址空间抽象
    - 静态内存分配
    - 动态内存分配
    - 页式存储管理
    - 局部性原理
    - 缺页异常
    - 虚拟页式存储
    - 置换算法

- OS的进程抽象
    - 支持动态创建程序执行
    - 支持多处理器并行
    - 相关知识点:
    - 进程抽象
    - 进程管理
    - 调度机制
    - 多处理器/多核架构
    - 多处理器调度
    - 实际OS调度

- OS的文件抽象
    - 处理数据的便捷持久存储
    - 相关知识点:
    - 文件抽象
    - 文件组织结构
    - 文件系统设计与实现

- 实验安排
  - 实验一：操作系统的基本支持
      - 覆盖内容: LibOS、批处理OS、多道程序与分时多任务OS
      - 知识点：特权级和切换
  - 实验二：地址空间
      - 覆盖内容: 地址空间抽象的OS
      - 知识点：页表
  - 实验三：进程管理与调度
      - 覆盖内容: 进程抽象的OS
      - 知识点：进程控制块PCB
  - 实验四：文件系统与进程间通信
      - 覆盖内容: 文件抽象的OS、可进程间通信的OS
      - 知识点：文件
  - 实验五：同步互斥
      - 覆盖内容: 可并发的OS
      - 知识点: 线程
  - 扩展实验（即大实验，课程设计）
      - 4周内完成基础实验1~5后，与老师协商选择完成扩展实验来代替考试
      - 扩展组件化操作系统的crates/modules/frameworks
          - 实现新feature（多核、新外设、新处理器、新功能）的支持
          - 参加全国大学生OS比赛

### 第二节 Compiler与OS

- 提纲
  - 硬件环境
  - 应用程序执行环境
  - 操作系统执行环境

- 硬件环境
  - 开发的硬件环境 (x86 架构)
  - 目标硬件环境 (RISC-V 架构)

- 应用程序执行环境
  - 编译器工作
    - 源码转换为汇编码
  - Assembler（汇编器）工作
    - 汇编码转换为机器码
  - Linker（链接器）工作
    - 多个机器码目标文件合并为单个机器码执行文件
  - OS工作
    - 加载/执行/管理机器码执行文件

- 操作系统执行环境
  - Compiler/Assembler/Linker 工作流程
    - 从源码到汇编码，再到机器码，最后生成执行程序
    - Bootloader加载OS执行
  - 可执行文件格式
    - 三元组: CPU架构/厂商/操作系统
      - 示例: riscv32gc-unknown-linux-gnu, riscv64gc-unknown-none-elf
      - ELF: Executable and Linkable Format
  - 链接和执行过程展示
  - 函数库
    - 标准库 (依赖操作系统)
      - Rust: std 标准库
      - C：glibc, musl libc 
    - 核心库 (与操作系统无关)
      - Rust: core 核心库
      - C: Linux/BSD kernel libc
  - 裸机程序
    - 定义: 与操作系统无关的OS类型的程序 (Bare Metal program)
    - 示例代码及配置
  - ELF文件格式和文件头信息
    - 文件格式详情
    - 反汇编导出汇编程序指令
    - 主要段和内存布局
      - .text: 代码段
      - .rodata: 已初始化数据段，只读
      - .data: 可修改的全局数据
      - .bss: 未初始化数据段
      - 堆 (heap) 向高地址增长
      - 栈 (stack) 向低地址增长

### 第三节 硬件启动与软件启动

- 提纲
  - RISC-V开发板
  - QEMU启动参数和流程
  - x86启动流程

- RISC-V开发板
  - K210开发板
    - 基于RISC-V 64多核处理器
  - 哪吒D1开发板
    - 基于RISC-V 64单核处理器
  - HiFive Unmatched 开发板（U740）
    - 基于RISC-V 64多核处理器

- QEMU启动参数和流程
  - QEMU模拟器
    - 模拟一台64位RISC-V架构的计算机
      - 包含一个或多个CPU
      - 物理内存
      - 若干I/O外设
  - QEMU启动参数
    - 启动配置示例
      ```
      qemu-system-riscv64 \
          -machine virt \
          -nographic \
          -bios ../bootloader/rustsbi-qemu.bin \
          -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000
      ```
      - machine virt: 设置为名为virt的虚拟机
      - nographic: 不使用图形界面，只输出字符流
      - bios: 设置引导加载程序
      - device loader: 载入文件到指定的物理内存地址
  - QEMU启动流程
    - 启动阶段划分
      1. 固化在QEMU模拟计算机内存中的汇编程序初始化并执行bootloader
      2. Bootloader初始化并加载OS
      3. OS内核执行初始化工作

- x86启动流程
  - 真实计算机(x86)的启动流程
    1. Rom Stage: 在ROM上运行BIOS代码
    2. Ram Stage: 在RAM上运行代码，检测并初始化芯片组、主板等
    3. Bootloader Stage: 在存储设备上找到Bootloader并加载执行
    4. OS Stage: Bootloader初始化外设，在存储设备上找到OS并加载执行

### 第四节 实践：裸机程序 -- LibOS

- 提纲
  - 实验目标和思路
  - 实验要求
  - 实践步骤
  - 代码结构
  - 内存布局
  - 基于 GDB 验证启动流程
  - 函数调用
  - LibOS初始化
  - SBI调用

- LibOS的实验目标
  - 概念：裸机程序（Bare Metal Program）
    - 与操作系统无关的OS类型的程序
  - 功能：
    - 建立应用程序的执行环境
      - 让应用与硬件隔离
      - 简化应用访问硬件的难度和复杂性
    - 提供执行环境（Execution Environment）

- LibOS历史背景
  - 1949-1951年，J. Lyons and Co. 引入EDSAC计算机，联合设计LEO I系统
  - 子程序概念的引入
    - David Wheeler 发明子程序概念 – Wheeler Jump
    - 子程序库形成了最早的操作系统原型

- LibOS总体思路
  - 编译：设置编译器支持裸机程序
  - 构造：建立栈和SBI服务请求接口
  - 运行：OS的起始地址和执行环境初始化

- 实验要求
  - 理解LibOS的执行过程
    - 编写、编译、运行裸机程序
    - 懂得基于裸机程序的函数调用
    - 能看懂汇编代码伪代码和内嵌汇编代码
    - 初步理解SBI调用

- 实践步骤
  - 开发与实验环境准备
  - 移除标准库依赖
  - 支持函数调用
  - 基于SBI服务完成输出与关机
  - 理解程序的内存空间和栈

- 代码结构
  - os/src: 主要代码目录
    - console.rs: 格式化输出实现
    - entry.asm: 设置执行环境的汇编代码
    - lang_items.rs: 包含panic处理逻辑
    - linker-qemu.ld: 控制内核内存布局的链接脚本
    - main.rs: 内核主函数
    - sbi.rs: 调用底层SBI实现提供的接口

- 内存布局
  - .text: 代码段
  - .rodata: 已初始化数据段，只读
  - .data: 可修改的全局数据
  - .bss: 未初始化数据段
  - 堆 (heap) 向高地址增长
  - 栈 (stack) 向低地址增长

- 基于 GDB 验证启动流程
  - 使用GDB连接至QEMU进行调试
  - 分析加载和执行流程

- 函数调用
  - ABI 和 SBI 接口详解
  - 函数调用、返回和寄存器使用约定
  - 栈帧的管理和使用

- LibOS初始化
  - 从ASM到Rust的控制权转交
  - 清空bss段以初始化未分配的全局变量

- SBI调用
  - SBI服务接口
  - SBI服务编号
  -  汇编级SBI调用
  -  SBI调用：输出字符
  -   SBI调用：关机
  -  优雅地处理错误panic
  -  LibOS完整功能

## 第三讲: 基于特权级的隔离与批处理

### 第三讲总结
- 知识点
	- 特权级定义
	- 特权级切换
	- 系统调用
	- 外设中断
	- 软件异常
	- 系统调用设计与实现
	- 系统调用执行过程
	- 批处理操作系统的设计与执行




### 第一节 从OS角度看计算机系统
- OS与硬件的关系 
  - 计算机系统
    - 抽象层次的设计
    - 有效使用现有制造技术
    - 信息处理应用
  - 计算机系统抽象层次
    - 硬件支持OS支持应用
    - 操作系统位于硬件和应用之间
  - 指令集：软硬件接口
    - 硬件与OS的边界
    - 指令集+寄存器
  - OS是对硬件的虚拟与抽象
  - RISC-V处理器架构
  - uCore的框架结构
- OS与应用程序的关系
  - OS对应用程序执行的支持
    - 提供服务
    - 系统调用
    - 地址空间布局
  - OS为应用程序提供服务
    - 通过系统调用来提供服务
    - 系统调用是OS/APP的接口
  - 系统调用如何实现？
    - 调用过程
    - 直接或间接调用内核函数问题
  - 引入系统调用的目的
    - 增强安全性和可靠性
    - 函数调用的特征
  - 进程的地址空间
    - 内核页表隔离(KPTI)
- 隔离机制
  - 隔离要解决的问题
    - 防止程序互相破坏或监视
    - 防止进程干扰操作系统
    - 防止恶意程序、病毒、木马和bug
  - 隔离方法
    - 软件、硬件、网络基础隔离
  - OS隔离APP的分类
    - 控制隔离：特权级机制
    - 数据隔离：虚拟内存
    - 时间隔离：中断处理
    - 异常处理
  - 虚拟内存
    - 工作原理
    - 解决的问题
  - 控制隔离：特权模式
    - CPU硬件中的特权模式
    - Kernel Mode vs User Mode
  - 时间隔离：中断/异常机制
    - 中断处理例程
    - 时钟中断
    - 异常处理例程
    - 系统调用处理例程
  - 中断 vs 异常 vs 系统调用
    - 触发者、响应方式、触发机制、处理机制
  - 进程切换 vs 函数切换
    - 比较图解
- 小结
  - 计算机硬件与操作系统的关系
  - 操作系统与应用程序的关系
  - 操作系统如何隔离与限制应用程序
### 第二节: 从OS角度看RISC-V
- 主流CPU比较
  - x86和ARM设计复杂性
    - 兼容性问题
    - 历史遗留问题
  - RISC-V特点
    - 简洁
    - 灵活
    - 可扩展
- RISC-V系统模式
  - 系统模式概述
    - ABI/SBI/HBI
    - AEE/SEE/HEE
    - HAL
    - 虚拟机监视器 (Hypervisor)
  - RISC-V相关术语
    - AEE, ABI, SBI, SEE, HEE, Hypervisor, HBI
  - 不同软件层的隔离支持
  - 单应用场景
    - 应用通过ABI运行在AEE上
  - 操作系统场景
    - 通过ABI与OS通信，OS通过SBI与SEE通信
  - 虚拟机场景
    - 支持多个操作系统
  - 应用场景对比
    - 从小型设备到数据中心服务器
  - 硬件线程和异常处理
    - 特权级保护机制
    - 异常导致自陷
- RISC-V特权级
  - 多个特权级
    - U: User
    - S: Supervisor
    - H: Hypervisor
    - M: Machine
  - 执行环境和跨越特权级
    - 使用ecall和mret等指令
  - 特权级的灵活组合
    - 需求变化下的硬件设计
  - 各模式详解
    - 用户态(U-Mode)
    - 内核态(S-Mode)
    - H-Mode
    - 物理机模式(M-Mode)
- RISC-V CSR寄存器
  - 寄存器分类
    - 通用寄存器
    - 控制状态寄存器 (CSR)
  - 通过CSR实现隔离
    - 权力、时间、数据隔离
  - CSR功能和作用
    - 信息类
    - Trap设置
    - Trap处理
    - 内存保护
- RISC-V系统编程
  - 用户态编程
    - 使用系统调用
    - 示例：hello world
    - 执行特权指令示例
    - 特权操作说明
  - M-Mode编程
    - 中断机制和异常机制
    - 中断/异常硬件响应
    - 中断/异常控制权移交
  - 内核编程
    - S-Mode中断控制和状态寄存器
    - 中断/异常机制
    - 虚存机制
    - 地址转换示例
- 小结
  - RISC-V架构和特权级的理解
  - 硬件与软件的交互方式
  - 软件间如何切换和控制
### 第三节: 实践：批处理操作系统
- 实验目标
  - 让APP与OS隔离
  - 自动加载并运行多个程序
  - 理解特权级和特权级切换
  - 实现系统调用
- 实践步骤
  - 构造包含OS和多个APP的单一执行镜像
  - 通过批处理支持多个APP的自动加载和运行
  - 利用硬件特权级机制实现对操作系统自身的保护
  - 支持跨特权级的系统调用
  - 实现特权级的切换
- 软件架构
  - 构建应用
    - 把多个应用合在一起与OS形成一个二进制镜像
  - 改进OS
    - 加载和执行程序、特权级上下文切换
  - 系统调用设计
    - 设计支持系统调用的库
- 相关硬件
  - RISC-V陷入(trap)类指令
    - ecall 和 ebreak
  - 特权指令
    - sret
  - 异常向量表
    - 描述各种异常类型和代码
- 应用程序设计
  - 应用与底层支撑库分离
  - 引入外部库
  - 设计支撑库
    - 定义用户库的入口点 _start
  - 内存布局
    - 设计应用程序的内存布局
  - 系统调用
    - 应用程序的系统调用执行流
    - 系统调用封装和参数传递
- 内核程序设计
  - 应用管理和加载
    - 将应用程序映像链接到内核
    - 应用程序管理数据结构
    - 加载应用程序二进制码
  - 特权级切换
    - 特权级切换相关CSR
    - 特权级切换后的硬件逻辑
    - 返回用户态让应用执行
  - Trap处理
    - Trap上下文数据结构
    - 保存Trap上下文
    - 调用trap_handler
    - 恢复Trap上下文
  - 执行应用程序
    - 应用程序的执行时机
    - 让应用程序执行
    - 切换到下一个应用程序

## 第四讲 多道程序与分时多任务


### 第四讲总结
- 知识点
	- 上下文
		- 函数上下文
		- 中断上下文
		- 任务上下文
	- 任务生命周期
	- 任务执行过程
	- 调度
  	- 协作式调度
  	- 抢占式调度
    	- 时钟中断的作用
	- 多道程序操作系统的设计与运行过程
	- 分时多任务操作系统的设计与运行过程


### 第一节: 进程和进程模型
- 多道程序与协作式调度
  - 历史
    - 大型机到小型机的过渡时期
    - OS/360, DEC公司的PDP系列
  - 多道程序概念
    - 内存中存在多个可执行程序
    - 共享处理器
  - 作业(Job)
    - 应用的一次执行过程
  - 协作式调度
    - 程序主动放弃处理器使用
    - 操作系统不会打断正在执行的程序
- 分时多任务与抢占式调度
  - 历史背景
    - 小型机普及，多用户系统需求增加
    - DEC的VMS, MIT的CTSS, AT&T的UNIX
  - 用户视角的分时多任务
    - 各程序分时共享处理器
    - 操作系统按时间片分配CPU时间
  - OS视角的分时多任务
    - 进程: 动态执行过程的程序实例
    - 进程切换
  - 抢占式调度
    - 进程被动地放弃处理器使用
    - 时钟硬件中断使操作系统可以打断程序
- 进程的概念
  - 进程特点
    - 动态性, 并发性, 有限度的独立性
  - 进程与程序的区别
    - 进程是动态且暂时的
    - 程序是静态且永久的
  - 进程状态
    - 包括控制流, 数据, 和管理数据
  - 进程控制块 (PCB)
    - 操作系统管理进程的核心数据结构
- 进程模型
  - 进程状态变迁
    - 创建, 就绪, 运行, 等待, 唤醒, 抢占, 退出
  - 三状态进程模型
    - 就绪, 执行, 阻塞
  - 进程状态变迁与系统调用
    - 涉及系统调用如 exit, sleep 等
  - 进程切换
    - 在任务生命周期中进行任务切换的时机
### 第二节: 实践：多道程序与分时多任务操作系统
- 实验目标和步骤
  - 实验目标
    - MultiprogOS: 提高多个应用的总体性能和效率
    - BatchOS: 让APP与OS隔离，提高安全性和效率
    - LibOS: 让应用与硬件隔离，简化访问硬件的复杂性
  - 实验要求
    - 理解协作式调度和抢占式调度
    - 理解任务和任务切换
    - 能写多道程序操作系统和分时多任务操作系统
  - 实践步骤
    - 编译应用程序和内核为一个镜像
    - 修改APP链接脚本定制起始地址
    - 加载执行应用与切换任务
- 多道批处理操作系统设计
  - 软件架构
    - 应用程序独立编译合并至OS镜像
    - 完善任务管理功能
  - 代码结构
    - 构建应用
    - 改进OS支持任务切换
- 应用程序设计
  - 项目结构
    - 包含编号的应用程序
  - 内存布局
    - 使用build.py工具定制链接脚本
  - yield系统调用
    - 让应用主动放弃处理器
- LibOS：支持应用程序加载
  - 多道程序加载
    - 将应用加载到不同的物理地址
  - 执行程序
    - 内核态到用户态的切换
- BatchOS：支持多道程序协作调度
  - 任务控制块
    - 管理任务运行所需信息
  - 协作式调度
    - sys_yield和sys_exit系统调用
  - 任务切换
    - 暂停一个应用执行过程并继续另一应用
- MultiprogOS：分时多任务OS
  - 基本思路
    - 设置时钟中断和统计时间片
    - 抢占式调度
  - 时钟中断与计时器
    - 设置和处理时钟中断
  - 抢占式调度实现
    - 通过时钟中断进行任务切换
## 第五讲 物理内存管理


### 第五讲总结
- 知识点
	- 地址空间概念
	- 内存分配
  	- 静态内存分配
  	- 动态内存分配
  	- 连续内存分配
  	- 非连续内存分配
	- 物理内存管理
  	- 分页机制
    	- 多级页表的设计与实现
    	- 访存异常及其软硬件协同处理过程
  	- 分段机制
	- 基于地址空间的分时多任务操作系统的设计与执行


### 第一节: 地址空间
- 计算机的存储层次
  - 物理地址和逻辑地址
    - 物理地址: 内存芯片级单元寻址
    - 逻辑地址: CPU执行机器指令时使用的地址
    - 线性地址(虚拟地址): 跟逻辑地址类似，无段式管理时与逻辑地址相同
  - 计算机的存储多层结构
    - 从寄存器到磁盘的多层存储结构
  - 操作系统对内存资源的抽象
    - 描述操作系统如何通过不同技术管理内存
  - 内存管理方式
    - 包括重定位、分段、分页、虚拟存储等
  - 存储层次结构示意
    - 展示了计算机中的存储层次结构
- 地址和地址空间
  - 地址空间的定义
    - 物理地址空间、虚拟地址空间、逻辑地址空间
  - 逻辑地址生成
    - 展示逻辑地址是如何生成的
  - 地址生成时机
    - 编译时、加载时、执行时的地址生成
  - 地址生成过程
    - CPU, MMU, 内存间的互动过程
  - 地址检查
    - 展示地址转换过程中的异常情况处理
- 虚拟存储的作用
  - 外存的缓存
    - 虚拟内存作为外存的缓存机制
  - 简化应用编译和加载运行
    - 通过独立地址空间简化编译链接、加载、共享等
  - 保护数据
    - 通过独立地址空间和地址转换机制保护数据
### 第二节: 内存分配
- 内存分配方式
  - 静态内存分配
    - 编译时完成
    - 全局、静态变量和代码所在段
  - 动态内存分配
    - 运行时进行
    - 栈和堆
    - malloc() 和 free() 函数
- 动态内存分配接口
  - malloc()
    - 分配指定大小的连续堆内存
  - free()
    - 释放已分配的堆内存
- 连续内存分配
  - 定义
    - 分配一块不小于指定大小的连续内存区域
  - 动态分区分配
    - 分配可变大小的连续内存块
    - 处理碎片问题
  - 分配策略
    - 最先匹配 (First-fit)
    - 最佳匹配 (Best-fit)
    - 最差匹配 (Worst-fit)
  - 伙伴系统 (Buddy System)
    - 快速分配和释放，避免外碎片
- 非连续内存分配
  - 概念与需求背景
    - 解决大内存块分配和碎片问题
  - 页式存储管理
    - 物理页面和逻辑页面
    - 页表和多级页表
    - 反置页表和段页式存储管理
  - 内存分配示例
    - 应用调用malloc的流程
    - 地址空间的变化和实际操作
### 第三节: 实践：建立地址空间的OS (ASOS)
- 实验目标和步骤
  - 以往目标
    - 提高性能、简化开发、加强安全
  - 实验目标
    - 简化编程，隔离APP访问的内存地址空间
  - 实验要求
    - 理解地址空间、页机制，处理页访问异常
  - 总体思路
    - 综合使用页表机制，特权级切换，地址空间切换
  - 历史背景
    - 虚拟内存技术的起源和发展
- 系统架构
  - 代码结构
    - 用户程序和内核的代码组织
  - RISC-V SV39页机制
    - 页表基址寄存器satp的功能和设置
- 用户视角的地址空间
  - ASOS地址空间
    - 用户与内核地址空间的配置和管理
  - 跳板页
    - 特权级切换和地址空间切换的实现机制
  - 应用的地址空间
    - 应用程序的内存布局和地址空间配置
- 内核管理地址空间
  - 管理物理内存
    - 物理内存的分配与管理策略
  - 建立内核/应用页表
    - 页表的创建和管理
  - 管理地址空间
    - 地址空间的动态管理和优化
- 实现ASOS
  - 启动分页模式
    - 初始化页表和启动页机制
  - 实现跳板机制
    - 解决内核与应用之间的特权级和地址空间切换问题
  - 加载和执行应用程序
    - 应用程序的加载和执行流程
  - 改进Trap处理的实现
    - Trap机制的改进和优化
  - 改进sys_write的实现
    - 系统调用的实现与优化
## 第六讲 虚拟存储管理


### 第六讲总结
- 知识点
	- 局部性原理
	- 虚拟存储基本概念
	- Page Fault异常
	- 局部页面置换算法
	- 全局页面置换算法
	- Belady异常	



### 第一节: 虚拟存储概念
- 虚拟存储技术的需求
  - 需求背景
    - 程序规模增长迅速，内存需求大于可用内存
    - 理想中的存储器特性：大容量、快速度、低成本、非易失性
  - 基本思路
    - 内存不够时，外存来补，使用覆盖、交换和虚拟存储技术
- 覆盖技术
  - 目标
    - 让程序员手动在较小的内存中运行较大程序
  - 基本原理
    - 不同时间段的函数或模块共享一块内存空间
  - 示例与不足
    - 增加编程复杂度和执行时间
- 交换技术
  - 基本思路
    - 操作系统以程序为单位自动换入换出内存
  - 面临的问题
    - 何时发生交换，程序如何重定位
  - 交换区大小建议与技术比较
    - 对比覆盖和交换技术
- 虚拟存储的基本概念
  - 定义与思路
    - 虚拟存储 = 内存 + 外存
  - 局部性原理
    - 程序执行中数据和指令的访问集中在短时间和小区域内
  - 虚拟存储的基本特征
    - 不连续性、大用户空间、部分交换
  - 底层支撑
    - 硬件（MMU/TLB/PageTable）和软件（OS）
- 缺页异常
  - 处理流程
    - 从产生缺页到修改页表项，并重新执行指令
  - 性能考虑
    - 缺页率、写回概率与有效存储访问时间(EAT)
  - 存储位置
    - 交换空间和磁盘文件
### 第二节: 局部页面置换算法
- 页面置换算法的基本概念
  - 功能
    - 选择被置换的物理页面
  - 设计目标
    - 减少缺页次数和换入/换出次数
  - 评价方法
    - 记录并模拟页面访问，统计缺页次数
- 最优页面置换算法 (OPT, optimal)
  - 工作原理
    - 置换在未来最长时间不访问的页面
  - 特征和示例
    - 缺页最少，理想情况下的算法，无法预知未来访问
- 先进先出页面置换算法 (FIFO)
  - 工作原理
    - 选择驻留时间最长的页面进行置换
  - 特征和示例
    - 实现简单，性能较差，可能会有Belady现象
- 最近最久未使用页面置换算法 (LRU, Least Recently Used)
  - 工作原理
    - 选择最长时间没有被引用的页面进行置换
  - 特征和示例
    - LRU是最优算法的一种近似，实现开销大
- 时钟页面置换算法 (Clock)
  - 工作原理
    - 环形链表形式，选择访问位为0的页面进行置换
  - 特征和示例
    - 是LRU和FIFO的折中，实现相对简单
- 改进的时钟页面置换算法
  - 工作原理
    - 类似时钟算法，但跳过修改过的页面以避免频繁写入
  - 特征和示例
    - 减少了写入外存的次数，适用于写操作较多的场景
- 最不常用页面置换算法 (LFU, Least Frequently Used)
  - 工作原理
    - 置换访问频率最低的页面
  - 特征和示例
    - 开销大，可能保留长期不用但曾经频繁访问的页面
- Belady现象
  - 定义
    - 分配的物理页面数增加时，缺页次数反而升高的异常现象
  - 触发条件
    - 使用FIFO等算法时可能触发，因为这些算法与程序访问内存的动态特征矛盾
### 第三节: 全局页面置换算法
- 全局页面置换算法的定义
  - 功能
    - 根据系统整体需求自动调整各进程物理页面数
  - 设计目标
    - 根据进程在不同阶段的内存需求变化动态调整
- 工作集页面置换算法
  - 定义
    - 根据进程的实际运行情况，即时更新其工作集
  - 实现方法
    - 维护一个固定大小的最近访问页面列表
  - 工作集示例
    - 展示不同时刻的工作集变化
- 缺页率页面置换算法
  - 定义
    - 根据缺页率来动态调整进程的物理内存占用
  - 实现方法
    - 监控缺页率，根据设定阈值增减分配给进程的内存页面
  - 缺页率示例
    - 展示不同配置下的缺页率变化
- 抖动问题解释
  - 定义
    - 因为过度的页面置换导致系统性能下降的现象
  - 解决策略
    - 平衡系统载入的进程数量和分配给每个进程的物理页面数
## 第七讲 进程管理与单处理器调度


### 第七讲总结
- 知识点
	- 进程概念
	- 进程运行状态
	- 进程管理
  	- 进程控制块
  	- 进程管理系统调用及其之间的关系
    	- fork
    	- exec
    	- waitpid
    	- exit
    - 相关系统调用与进程运行状态的关系
	- 调度策略/算法
  	- 基本调度策略/算法
    	- 评价指标
    	- FCFS
    	- SJF
    	- SRT
    	- HRRN
    	- MQ
    	- MLFQ
    	- FSS
  	- 实时调度策略/算法
    	- 评价指标
    	- 可调度性概念
    	- 静态优先级调度与动态优先级调度
    	- 实时调度算法
      	- 速率单调调度算法
      	- 最早截止时间优先算法
      	- 最低松弛度优先算法
    	- 优先级反置问题及其解决方案
      	- 优先级继承(Priority Inheritance)策略
      	- 优先级天花板协议（priority ceiling protocol）
	- 支持进程的操作系统的设计与执行


### 第一节: 进程管理
- 进程的基本概念
  - 需求背景
    - 硬件性能提升
    - 开发者和使用者需求增加
  - 进程提供的抽象
    - 独立控制流
    - 私有地址空间
  - 进程的实现和资源视角
    - 数据结构和动态操作
    - 资源占用集合
- 进程管理
  - 系统调用
    - 创建、执行、终止、等待、获取PID
  - 进程控制块 (PCB)
    - 管理进程状态和属性
  - 进程创建和程序加载
    - fork, exec, exit, waitpid 的过程和示例
  - 进程等待与退出
    - wait 和 exit 的实现和影响
- 关于Fork()的思考
  - Fork()的开销和问题
    - 复制代价高，经常接着exec无效复制
  - 重新思考Fork
    - 历史偶然性，不再是最佳设计
### 第二节: 单处理器调度
- 处理机调度概念
  - CPU资源的时分复用
    - 进程切换和处理机调度
  - 调度时机
    - 内核执行调度的条件
  - 调度策略
    - 如何从就绪队列中选择下一个执行进程
  - 处理机资源的使用模式
    - 进程在CPU和I/O操作间交替
- 调度算法
  - FCFS、SJF、SRT和HRRN
    - 简介和特性
  - 时间片轮转算法RR
    - 基本原理和示例
  - MQ、MLFQ和FSS
    - 多级队列、多级反馈队列与公平共享调度
  - 比较调度算法的准则
    - 评价标准如吞吐量、响应时间、公平等
### 第三节: 实时调度
- 实时操作系统
  - 定义
    - 正确性依赖于时间和功能的操作系统
  - 分类
    - 强实时系统
    - 软实时系统
  - 特性
    - 时间约束的可预测性
- 实时调度
  - 速率单调调度算法 (Rate Monotonic, RM)
  - 最早截止时间优先算法 (Earliest Deadline First, EDF)
  - 最低松弛度优先算法 (Least Laxity First, LLF)
- 优先级反置
  - 定义
    - 高优先级进程因等待低优先级进程释放资源而延迟执行
  - 解决方案
    - 优先级继承
    - 优先级天花板协议
### 第四节: 实践：支持进程的操作系统 (POS)
- 实验目标和步骤
  - 以往目标
    - 提高性能、简化开发、加强安全
  - 实验目标
    - 整合特权级、地址空间、任务成进程
    - 进程成为资源的拥有者
    - 扩展进程动态特征，支持动态创建子进程等
  - 实验要求
    - 理解进程概念和管理机制
    - 初步认识进程调度
    - 掌握shell应用的编写与使用
  - 总体思路
    - 包括编译、构造、运行阶段的详细步骤
- 代码结构
  - 改进OS
    - 包括修改的文件和新增功能
  - 核心数据结构
    - 描述与进程相关的核心数据结构
  - 应用的链接与加载支持
    - 实现基于应用名的应用加载
- 应用程序设计
  - 理解进程
    - 进程是正在执行的应用
  - 进程管理系统调用
    - 包括 fork, exec, exit, waitpid 的实现
  - 应用 shell
    - 执行流程和系统调用交互
- 内核程序设计
  - 创建初始进程
    - 初始化第一个用户态进程 `initproc`
  - 进程管理机制实现
    - 包括创建、切换、调度、回收等过程
  - 进程的链接与加载支持
    - 详细介绍如何加载并执行应用
  - 核心数据结构
    - 详细介绍进程控制块、进程管理器等结构
  - 进程管理机制实现
    - 实现进程的创建、执行、调度和资源回收
