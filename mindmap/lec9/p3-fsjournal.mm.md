### 第三节 支持崩溃一致性的文件系统

- 崩溃一致性问题
  - 文件数据不一致
    - 更新持久数据结构时可能遇到的断电或系统崩溃导致数据不一致
  - 崩溃一致性需求
    - 目标：将文件系统从一个一致状态原子地变迁到另一个一致状态
    - 困难：磁盘一次只提交一次写入，更新之间可能会发生崩溃或断电。
  - 文件更新过程示例
    - 一个应用以某种方式更新磁盘结构：将单个数据块附加到原有文件。
      - 1：调用lseek()将文件偏移量移动到文件新的末尾
      - 2：调用write()向文件发出单个4KB写入来完成数据更新的追加
      - 在上述过程间或过程中可能发生断电
    - 简化的文件系统结构
      - inode位图（inode bitmap，只有8位，每个inode一个）
      - data位图（data bitmap，也是8位，每个数据块一个）
      - inode（总共8个，编号为0到7，分布在4个块上）
      - data（总共8个，编号为0～7）
    - 一般正常情况下的数据更新操作
      - 需对磁盘执行3次单独写入：inode（I[v2]）、data bitmap（B[v2]）和data（Db）
      - 发出write()系统调用时，这些写操作通常不会立即发生。脏的inode、位图和新数据先在内存（页面缓存page cache，或缓冲区缓存buffer cache）中存在一段时间。
      - 当文件系统最终决定将它们写入磁盘时，文件系统将向磁盘发出必要的写入请求。
    - 文件操作中的崩溃场景
      - 1：只将数据块（Db）写入磁盘
      - 2：只有更新的inode（I[v2]）写入了磁盘
      - 3：只有更新后的位图（B [v2]）写入了磁盘
      - 4：inode（I[v2]）和位图（B[v2]）写入了磁盘，但没有写入数据（Db）
      - 5：写入了inode（I[v2]）和数据块（Db），但没有写入位图（B[v2]）
      - 6：写入了位图（B[v2]）和数据块（Db），但没有写入inode（I[v2]）
- 文件系统检查程序 fsck
  - 解决崩溃一致性问题的方法之一
  - 详细检查过程包括超级块检查、位图与inode间的一致性检查等
  - 检查和修复文件系统使其达到内部一致状态
- 日志文件系统
  - 使用日志（预写日志）来保证文件系统的崩溃一致性
    - 更新磁盘时，在覆写结构之前，首先写下一点小注记（在磁盘上的其他地方，在一个众所周知的位置），描述你将要做的事情。写下这个注记就是“预写”部分，把它写入一个结构，并组织成“日志”。
    - 发生崩溃时，能够返回并查看你所做的注记，从而能准确知道要修复的内容（以及如何修复它），然后重试。
  - 数据日志操作
    - 文件更新
      - 日志写入 Journal write：
        - 将事务的内容（包括TxB、元数据和数据）写入日志，等待这些写入完成。
      - 日志提交 Journal Commit：
        - 将事务提交块（包括TxE）写入日志，等待写完成，事务被认为已提交（committed）。
      - 加检查点 Checkpoint
        - 将更新内容（元数据和数据）写入其最终的磁盘位置。
    - 崩溃恢复
      - 崩溃发生在Journal Commit完成前：文件系统可以丢掉之前写入的log。
      - 崩溃发生在Checkpoint完成后：不用做事。
      - 崩溃发生在Journal Commit后，Checkpoint之前：根据已经commited的log记录信息执行Checkpoint操作。
  - 元数据日志操作：**数据+元数据日志 --> 元数据日志**
    - 文件更新
      - Data write：写入数据到磁盘的对应位置
      - Journal metadata write：将TxB以及对应的文件metadata操作写入到事务中
      - Journal commit：写入TxE，并等待完成。完成后，这个事务是committed。
      - Checkpoint metadata：将事务中的metadata的操作相关数据，分别各自回写到各自的磁盘位置中。
      - Free：释放journal区域的log记录
      - 注：通过强制首先写入数据，文件系统可保证指针永远不会指向垃圾数据。



