###  第三节 实践：支持线程/协程的OS(TCOS)
- 实验目标
  - 提高并发执行效率，支持线程和协程
    - 在进程内实现多个控制流（线程/协程）的执行
    - 在用户态或内核态管理多个控制流（线程/协程）
  - 理解基于任务（Task）的进程/线程/协程抽象
  - 理解进程/线程/协程的实现与运行机制
  - 会写支持线程/协程的达科塔盗龙OS
- 设计实现用户态管理的用户线程
  - 如何管理协程/线程/进程？
    - 任务上下文
    - 用户态管理
    - 内核态管理
  - 用户态管理线程的任务控制块
    ```rust
    struct Task { //线程控制块
        id: usize,
        stack: Vec<u8>,
        ctx: TaskContext,
        state: State,
    }
    pub struct TaskContext { //线程上下文
        x1: u64,  //ra: return addres 
        x2: u64,  //sp
        ...,  //s[0..11] 寄存器
        nx1: u64, //new return addres
    }
    ```
  - 用户态管理的线程控制接口和实现
    - 用户态线程管理运行时初始化
    - 用户态管理的线程创建
    - 用户态管理的线程切换 
    - 用户态管理的线程执行&调度     
- 设计实现内核态管理的用户线程
  - 如何管理协程/线程/进程？
    - 任务上下文
    - 用户态管理
    - 内核态管理
  - 内核态管理的用户线程的线程控制块
    - ```rust
      pub struct ProcessControlBlockInner {
          pub tasks: Vec<Option<Arc<TaskControlBlock>>>,
          pub task_res_allocator: RecycleAllocator,
          ...
      }  
      ```
  - 内核态管理的线程控制接口
    - 创建线程系统调用
      - 系统调用: thread_create
        - pub fn sys_thread_create(entry: usize, arg: usize) -> isize
        - 创建线程不需要建立新的地址空间;属于同一进程中的线程之间没有父子关系    
    - 线程退出系统调用
      - 系统调用: waittid
        - pub fn sys_waittid(tid: usize) -> i32
        - 进程/主线程通过 waittid 来等待它创建出来的线程（不是主线程）结束并回收它们在内核中的资源
        - 如果进程/主线程先调用了 exit 系统调用来退出，那么整个进程（包括所属的所有线程）都会退出
  - 线程管理与进程管理
    - 线程管理与进程管理的关系
      - 引入了线程机制后，进程相关的重要系统调用：fork 、 exec 、 waitpid 接口上没有变化，但完成的功能上需要有一定的扩展
    - fork与多个线程
      - 问题：“被fork的子进程是否要复制父进程的多个线程？”
        - 选择A：要复制多个线程；
        - 选择B：不复制，只复制当前执行fork的这个线程；
        - 选择C：不支持多线程进程执行fork这种情况  
      - 目前的rcore tutorial ，选择了C方案，简化了应用的使用场景
        - fork和create_thread（以及基于线程的信号量，条件变量等）不会同时出现。
        - 如果有fork，假定是这个应用是单线程的进程，所以只拷贝了这个单线程的结构。  
  - 内核态管理的线程的实现
    - 线程管理数据结构
      - 任务控制块 TaskControlBlock ：表示线程的核心数据结构
      - 任务管理器 TaskManager ：管理线程集合的核心数据结构
      - 处理器管理结构 Processor ：用于线程调度，维护线程的处理器状态
    - 实现系统调用  
      - 线程创建sys_thread_create  
        - 操作系统就需要在当前进程的基础上创建一个线程，建立好进程和线程的关系等，关键要素包括：
          - 线程的用户态栈：确保在用户态的线程能正常执行函数调用
          - 线程的内核态栈：确保线程陷入内核后能正常执行函数调用
          - 线程的跳板页：确保线程能正确的进行用户态<–>内核态切换
          - 线程上下文：即线程用到的寄存器信息，用于线程切换
      - 线程退出sys_exit
        - 当一个非主线程的其他线程发出 sys_exit 系统调用时，内核会调用 exit_current_and_run_next 函数退出当前线程并切换到下一个线程，但不会导致其所属进程的退出。
        - 当主线程 即进程发出这个系统调用，当内核收到这个系统调用后，会回收整个进程（这包括了其管理的所有线程）资源，并退出。
      - 等待线程结束sys_waittid  
        - 如果找到 tid 对应的线程，则尝试收集该线程的退出码 exit_tid ，否则返回错误（退出线程不存在）。
        - 如果退出码存在(意味该线程确实退出了)，则清空进程中对应此线程的线程控制块（至此，线程所占资源算是全部清空了），否则返回错误（线程还没退出）。
    - 线程执行中的特权级切换和调度切换
      - 线程执行中的特权级切换与第四讲中介绍的任务切换的设计与实现是一致的
      - 线程执行中的调度切换过程与第七讲中介绍的进程调度机制是一致的






