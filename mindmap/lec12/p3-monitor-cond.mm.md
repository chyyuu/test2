###  第三节 管程与条件变量
- 管程
  - 为什么引入管程？
    - 提高程序可读性
    - 程序易于修改和维护
    - 增强正确性和避免死锁
  - 管程的定义
    - 管程是一种用于多线程互斥访问共享资源的程序结构
    - 采用面向对象方法，简化了线程间的同步控制
    - 任一时刻最多只有一个线程执行管程代码
    - 正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复
  - 外部特征
    - 互斥：任一时刻管程中只能有一个活跃进程，通过锁竞争进入管程
    - 等待：进入管程的线程因资源被占用而进入等待状态
      - 每个条件变量表示一种等待原因，对应一个等待队列
      - 入口队列管理未进入管程的线程/进程
    - 唤醒：管程中等待的线程可以在其他线程释放资源时被唤醒
    - 管程操作：进入enter, 离开leave, 等待wait, 唤醒signal
      - T.enter过程：线程T在进入管程之前要获得互斥访问权(lock)
      - T.leave过程：当线程T离开管程时，如果紧急队列不为空，唤醒紧急队列中的线程，并将T所持锁赋予唤醒的线程；如果紧急队列为空，释放lock，唤醒入口等待队列某个线程
      - T.wait(c)：1)阻塞线程T自己，将T自己挂到条件变量c的等待队列；2)释放所持锁； 3)唤醒入口等待队列的一个或者多个线程；
      - T.signal(c)：1)把条件变量c的等待队列某个线程唤醒；2)把线程T所持lock给被唤醒的线程；3)把线程T自己挂在紧急等待队列
  - 管程的组成
    - 一个由过程（函数）、变量及数据结构等组成的一个集合。包括：
      - 一个锁：控制管程代码的互斥访问
      - 0或者多个条件变量: 管理共享数据的并发访问，每个条件变量有个等待（紧急）队列
      - 入口等待队列：管程入口处等待队列
      - 紧急等待队列：某个条件变量的等待队列
      - 条件变量队列：唤醒线程使用的等待队列
  - 管程实现方式
    - 如果线程T1处于阻塞状态，当线程T2执行signal操作唤醒T1后，如何确定哪个执行/哪个等待？
    - 管程中条件变量的释放处理方式：
    - Hoare类型：T2 通知完 T1后，T2 阻塞，T1 马上执行；等 T1 执行完，再唤醒 T2 执行
    - Hansen类型：T2 通知完 T1 后，T2 还会接着执行，T2 执行结束后（规定：最后操作是signal），然后 T1 再执行（将锁直接给T1）
    - MESA类型：T2 通知完 T1 后，T2 还会接着执行，T1 并不会立即执行，而是重新竞争访问权限
  - 管程中的if/while条件判断操作
    - 唤醒一个线程的两种选择：if->直接赋予锁 vs while->重新公平竞争锁
    - Hoare/Hansen类型：if
    - MESA类型：while
- 条件变量
  - 条件变量的定义
    - 条件变量用于线程间通信和协调
    - 它是一个结构体，包含了一个等待队列和一些基本操作函数
  - 条件变量的操作（以pthread为例）
    - 初始化：通过pthread_cond_init()函数初始化一个条件变量
    - 销毁：通过pthread_cond_destroy()函数销毁一个条件变量
    - 等待：通过pthread_cond_wait()函数在条件变量上等待，线程会自动解锁互斥锁并进入等待状态，直到被唤醒
    - 唤醒：通过pthread_cond_signal()或pthread_cond_broadcast()函数唤醒一个或多个等待在条件变量上的线程   
  - 条件变量的使用
    - 条件变量与互斥锁（mutex）配合，可实现线程间的同步和互斥
      - 创建条件变量和互斥锁，并初始化它们
      - 线程在持有互斥锁时，可修改或访问共享资源
      - 当共享资源被其他线程占用时，当前线程阻塞自己，并让出互斥锁，等待条件变量唤醒
      - 线程释放共享资源后，可通过条件变量唤醒等待在条件变量上的线程，让它们重新尝试获取共享资源并执行相应的操作
  - 条件变量的实现
    - 初始化
    - 等待 (wait)
    - 信号 (signal)
- 生产者-消费者问题的管程实现
  - 使用管程解决同步与互斥问题
  - 实现细节，如使用条件变量处理空和满的缓冲区状态
  - 解决生产者和消费者之间的依赖关系

